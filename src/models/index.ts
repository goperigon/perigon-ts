/**
 * Perigon API
 * The Perigon API provides access to comprehensive news and web content data. To use the API, simply sign up for a Perigon Business Solutions account to obtain your API key. Your available features may vary based on your plan. See the Authentication section for details on how to use your API key.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: data@perigon.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { z } from "zod";

export const SortBySchema = z.enum([
  "createdAt",
  "updatedAt",
  "relevance",
  "count",
  "totalCount",
]);

export type SortBy = z.infer<typeof SortBySchema>;

export const SortBy = {
  CreatedAt: "createdAt",
  UpdatedAt: "updatedAt",
  Relevance: "relevance",
  Count: "count",
  TotalCount: "totalCount",
} as const;

export const AllEndpointSortBySchema = z.enum([
  "relevance",
  "date",
  "reverseDate",
  "reverseAddDate",
  "addDate",
  "pubDate",
  "refreshDate",
]);

export type AllEndpointSortBy = z.infer<typeof AllEndpointSortBySchema>;

export const AllEndpointSortBy = {
  Relevance: "relevance",
  Date: "date",
  ReverseDate: "reverseDate",
  ReverseAddDate: "reverseAddDate",
  AddDate: "addDate",
  PubDate: "pubDate",
  RefreshDate: "refreshDate",
} as const;

export const CategoryHolderSchema = z.object({
  name: z.string().optional().nullable(),
});

export type CategoryHolder = z.infer<typeof CategoryHolderSchema>;

export const CategoryWithScoreHolderSchema = z.object({
  name: z.string().optional().nullable(),
  score: z.number().optional().nullable(),
});

export type CategoryWithScoreHolder = z.infer<
  typeof CategoryWithScoreHolderSchema
>;

export const CompanyHolderSchema = z.object({
  id: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  domains: z.array(z.string()).optional().nullable(),
  symbols: z.array(z.string()).optional().nullable(),
});

export type CompanyHolder = z.infer<typeof CompanyHolderSchema>;

export const EntityHolderSchema = z.object({
  data: z.string().optional().nullable(),
  type: z.string().optional().nullable(),
  mentions: z.number().optional().nullable(),
});

export type EntityHolder = z.infer<typeof EntityHolderSchema>;

export const EventTypeHolderSchema = z.object({
  name: z.string().optional().nullable(),
  type: z.string().optional().nullable(),
});

export type EventTypeHolder = z.infer<typeof EventTypeHolderSchema>;

export const IdNameHolderSchema = z.object({
  id: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
});

export type IdNameHolder = z.infer<typeof IdNameHolderSchema>;

export const LocationHolderSchema = z.object({
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  county: z.string().optional().nullable(),
  city: z.string().optional().nullable(),
  area: z.string().optional().nullable(),
});

export type LocationHolder = z.infer<typeof LocationHolderSchema>;

export const NameCountSchema = z.object({
  name: z.string().optional().nullable(),
  count: z.number().optional().nullable(),
});

export type NameCount = z.infer<typeof NameCountSchema>;

export const JournalistSchema = z.object({
  id: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  fullName: z.string().optional().nullable(),
  headline: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
  title: z.string().optional().nullable(),
  locations: z.array(LocationHolderSchema).optional().nullable(),
  updatedAt: z.string().optional().nullable(),
  topTopics: z.array(NameCountSchema).optional().nullable(),
  topSources: z.array(NameCountSchema).optional().nullable(),
  topCategories: z.array(NameCountSchema).optional().nullable(),
  topLabels: z.array(NameCountSchema).optional().nullable(),
  topCountries: z.array(NameCountSchema).optional().nullable(),
  avgMonthlyPosts: z.number().optional().nullable(),
  twitterHandle: z.string().optional().nullable(),
  twitterBio: z.string().optional().nullable(),
  imageUrl: z.string().optional().nullable(),
  linkedinUrl: z.string().optional().nullable(),
  linkedinConnections: z.number().optional().nullable(),
  linkedinFollowers: z.number().optional().nullable(),
  facebookUrl: z.string().optional().nullable(),
  instagramUrl: z.string().optional().nullable(),
  websiteUrl: z.string().optional().nullable(),
  blogUrl: z.string().optional().nullable(),
  tumblrUrl: z.string().optional().nullable(),
  youtubeUrl: z.string().optional().nullable(),
});

export type Journalist = z.infer<typeof JournalistSchema>;

export const KeywordHolderSchema = z.object({
  name: z.string().optional().nullable(),
  weight: z.number().optional().nullable(),
});

export type KeywordHolder = z.infer<typeof KeywordHolderSchema>;

export const LabelHolderSchema = z.object({
  name: z.string().optional().nullable(),
});

export type LabelHolder = z.infer<typeof LabelHolderSchema>;

export const CompanyCountSchema = z.object({
  id: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  domains: z.array(z.string()).optional().nullable(),
  symbols: z.array(z.string()).optional().nullable(),
  count: z.number().optional().nullable(),
});

export type CompanyCount = z.infer<typeof CompanyCountSchema>;

export const KeyPointSchema = z.object({
  point: z.string().optional().nullable(),
  references: z.array(z.string()).optional().nullable(),
});

export type KeyPoint = z.infer<typeof KeyPointSchema>;

export const LocationCountSchema = z.object({
  state: z.string().optional().nullable(),
  county: z.string().optional().nullable(),
  city: z.string().optional().nullable(),
  area: z.string().optional().nullable(),
  count: z.number().optional().nullable(),
});

export type LocationCount = z.infer<typeof LocationCountSchema>;

export const PersonCountSchema = z.object({
  wikidataId: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  count: z.number().optional().nullable(),
});

export type PersonCount = z.infer<typeof PersonCountSchema>;

export const PersonHolderSchema = z.object({
  wikidataId: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
});

export type PersonHolder = z.infer<typeof PersonHolderSchema>;

export const QuestionSchema = z.object({
  question: z.string().optional().nullable(),
  answer: z.string().optional().nullable(),
  references: z.array(z.string()).optional().nullable(),
});

export type Question = z.infer<typeof QuestionSchema>;

export const RecordStatHolderSchema = z.object({
  name: z.string().optional().nullable(),
  count: z.number().optional().nullable(),
});

export type RecordStatHolder = z.infer<typeof RecordStatHolderSchema>;

export const SentimentHolderSchema = z.object({
  positive: z.number().optional().nullable(),
  negative: z.number().optional().nullable(),
  neutral: z.number().optional().nullable(),
});

export type SentimentHolder = z.infer<typeof SentimentHolderSchema>;

export const CoordinateSchema = z.object({
  lat: z.number().optional().nullable(),
  lon: z.number().optional().nullable(),
});

export type Coordinate = z.infer<typeof CoordinateSchema>;

export const SourceLocationSchema = z.object({
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  county: z.string().optional().nullable(),
  city: z.string().optional().nullable(),
  coordinates: CoordinateSchema.optional().nullable(),
});

export type SourceLocation = z.infer<typeof SourceLocationSchema>;

export const SourceHolderSchema = z.object({
  domain: z.string().optional().nullable(),
  paywall: z.boolean().optional().nullable(),
  location: SourceLocationSchema.optional().nullable(),
});

export type SourceHolder = z.infer<typeof SourceHolderSchema>;

export const TopicHolderSchema = z.object({
  name: z.string().optional().nullable(),
});

export type TopicHolder = z.infer<typeof TopicHolderSchema>;

export const NewsClusterSchema = z.object({
  createdAt: z.string().optional().nullable(),
  updatedAt: z.string().optional().nullable(),
  initializedAt: z.string().optional().nullable(),
  id: z.string().optional().nullable(),
  duplicateOf: z.string().optional().nullable(),
  slug: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  summary: z.string().optional().nullable(),
  shortSummary: z.string().optional().nullable(),
  summaryReferences: z.array(z.string()).optional().nullable(),
  imageSource: SourceHolderSchema.optional().nullable(),
  imageUrl: z.string().optional().nullable(),
  keyPoints: z.array(KeyPointSchema).optional().nullable(),
  questions: z.array(QuestionSchema).optional().nullable(),
  uniqueSources: z.array(z.string()).optional().nullable(),
  selectedArticles: z
    .array(z.unknown() /* Circular reference to ArticleSchema */)
    .optional()
    .nullable(),
  sentiment: SentimentHolderSchema.optional().nullable(),
  uniqueCount: z.number().optional().nullable(),
  reprintCount: z.number().optional().nullable(),
  totalCount: z.number().optional().nullable(),
  countries: z.array(RecordStatHolderSchema).optional().nullable(),
  topCountries: z.array(z.string()).optional().nullable(),
  topics: z.array(RecordStatHolderSchema).optional().nullable(),
  topTopics: z.array(TopicHolderSchema).optional().nullable(),
  categories: z.array(RecordStatHolderSchema).optional().nullable(),
  topCategories: z.array(CategoryHolderSchema).optional().nullable(),
  taxonomies: z.array(RecordStatHolderSchema).optional().nullable(),
  topTaxonomies: z.array(CategoryHolderSchema).optional().nullable(),
  people: z.array(PersonCountSchema).optional().nullable(),
  topPeople: z.array(PersonHolderSchema).optional().nullable(),
  companies: z.array(CompanyCountSchema).optional().nullable(),
  topCompanies: z.array(CompanyHolderSchema).optional().nullable(),
  locations: z.array(LocationCountSchema).optional().nullable(),
  topLocations: z.array(LocationHolderSchema).optional().nullable(),
  highlights: z.record(z.string(), z.array(z.string())).optional().nullable(),
});

export type NewsCluster = z.infer<typeof NewsClusterSchema>;

export const PlaceSchema = z.object({
  osmId: z.string().optional().nullable(),
  road: z.string().optional().nullable(),
  quarter: z.string().optional().nullable(),
  suburb: z.string().optional().nullable(),
  city: z.string().optional().nullable(),
  town: z.string().optional().nullable(),
  county: z.string().optional().nullable(),
  stateDistrict: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  postcode: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  countryCode: z.string().optional().nullable(),
  amenity: z.string().optional().nullable(),
  neighbourhood: z.string().optional().nullable(),
  coordinates: CoordinateSchema.optional().nullable(),
});

export type Place = z.infer<typeof PlaceSchema>;

export const ArticleSchema = z.object({
  url: z.string().optional().nullable(),
  authorsByline: z.string().optional().nullable(),
  articleId: z.string().optional().nullable(),
  clusterId: z.string().optional().nullable(),
  source: SourceHolderSchema.optional().nullable(),
  imageUrl: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  language: z.string().optional().nullable(),
  pubDate: z.string().optional().nullable(),
  addDate: z.string().optional().nullable(),
  refreshDate: z.string().optional().nullable(),
  score: z.number().optional().nullable(),
  title: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
  content: z.string().optional().nullable(),
  enContentWordCount: z.number().optional().nullable(),
  medium: z.string().optional().nullable(),
  links: z.array(z.string()).optional().nullable(),
  labels: z.array(LabelHolderSchema).optional().nullable(),
  eventTypes: z.array(EventTypeHolderSchema).optional().nullable(),
  matchedAuthors: z.array(IdNameHolderSchema).optional().nullable(),
  claim: z.string().optional().nullable(),
  verdict: z.string().optional().nullable(),
  keywords: z.array(KeywordHolderSchema).optional().nullable(),
  topics: z.array(TopicHolderSchema).optional().nullable(),
  categories: z.array(CategoryHolderSchema).optional().nullable(),
  taxonomies: z.array(CategoryWithScoreHolderSchema).optional().nullable(),
  entities: z.array(EntityHolderSchema).optional().nullable(),
  companies: z.array(CompanyHolderSchema).optional().nullable(),
  sentiment: SentimentHolderSchema.optional().nullable(),
  summary: z.string().optional().nullable(),
  shortSummary: z.string().optional().nullable(),
  translation: z.string().optional().nullable(),
  translatedTitle: z.string().optional().nullable(),
  translatedDescription: z.string().optional().nullable(),
  translatedSummary: z.string().optional().nullable(),
  locations: z.array(LocationHolderSchema).optional().nullable(),
  reprint: z.boolean().optional().nullable(),
  reprintGroupId: z.string().optional().nullable(),
  places: z.array(PlaceSchema).optional().nullable(),
  people: z.array(PersonHolderSchema).optional().nullable(),
  cluster: NewsClusterSchema.optional().nullable(),
  journalists: z.array(JournalistSchema).optional().nullable(),
  highlights: z.record(z.string(), z.array(z.string())).optional().nullable(),
});

export type Article = z.infer<typeof ArticleSchema>;

export const CoordinateFilterSchema = z.object({
  lat: z.number().optional().nullable(),
  lon: z.number().optional().nullable(),
  radius: z.number().optional().nullable(),
});

export type CoordinateFilter = z.infer<typeof CoordinateFilterSchema>;

export const ArticleSearchFilterSchema = z.object({
  /**
   * Filter by specific article identifiers. Accepts either a single ID or an array of IDs. Returns only articles matching these IDs.
   */
  articleId: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific story identifiers. Accepts either a single ID or an array of IDs. Returns only articles belonging to these stories.
   */
  clusterId: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by specific publisher domains or subdomains. Accepts either a single domain or an array of domains. Multiple values create an OR filter.
   */
  source: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles from specific publisher domains or subdomains. Accepts either a single domain or an array of domains. Multiple values create an AND-exclude filter.
   */
  excludeSource: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles using Perigon's curated publisher bundles (e.g., top100, top25tech). Accepts either a single source group or an array. Multiple values create an OR filter to include articles from any of the specified bundles.
   */
  sourceGroup: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by their language using ISO-639 two-letter codes in lowercase (e.g., en, es, fr). Accepts either a single language code or an array. Multiple values create an OR filter.
   */
  language: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles in specific languages using ISO-639 two-letter codes in lowercase. Accepts either a single language code or an array. Multiple values create an AND-exclude filter.
   */
  excludeLanguage: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by editorial labels such as Opinion, Paid-news, Non-news, Fact Check, or Press Release. View our docs for an exhaustive list of labels. Accepts either a single label or an array. Multiple values create an OR filter.
   */
  label: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles with specific editorial labels. Accepts either a single label or an array. Multiple values create an AND-exclude filter, removing all content with any of these labels.
   */
  excludeLabel: z.array(z.string()).optional().nullable(),
  /**
   * Filter by Google Content Categories. Must pass the full hierarchical path of the category. Accepts either a single path or an array. Example: taxonomy=/Finance/Banking/Other,/Finance/Investing/Funds. Multiple values create an OR filter.
   */
  taxonomy: z.array(z.string()).optional().nullable(),
  /**
   * Filter by broad content categories such as Politics, Tech, Sports, Business, or Finance. Accepts either a single category or an array. Use none to find uncategorized articles. Multiple values create an OR filter.
   */
  category: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific topics such as Markets, Crime, Cryptocurrency, or College Sports. Accepts either a single topic or an array. Topics are more granular than categories, and articles can have multiple topics. Multiple values create an OR filter.
   */
  topic: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles with specific topics. Accepts either a single topic or an array. Multiple values create an AND-exclude filter, removing all content with any of these topics.
   */
  excludeTopic: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by countries they mention using two-letter country codes in lowercase (e.g., us, gb, jp). Accepts either a single country code or an array. Multiple values create an OR filter. See documentation for supported country codes.
   */
  country: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles from specific countries using two-letter country codes in lowercase. Accepts either a single country code or an array. Multiple values create an AND-exclude filter. See documentation for supported country codes.
   */
  excludeCountry: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles where specified countries play a central role in the content, not just mentioned. Uses two-letter country codes in lowercase. Accepts either a single country code or an array. Multiple values create an OR filter. See documentation for supported country codes.
   */
  locationsCountry: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles where specified countries play a central role in the content. Accepts either a single country code or an array. Multiple values create an AND-exclude filter, removing articles focused on any of these countries. See documentation for supported country codes.
   */
  excludeLocationsCountry: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles where specified states play a central role in the content. Accepts either a single state code or an array. Multiple values create an OR filter. Uses two-letter state codes in lowercase. See documentation for supported state codes.
   */
  state: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles where specified states play a central role. Accepts either a single state code or an array. Multiple values create an AND-exclude filter, removing articles focused on any of these states. See documentation for supported state codes.
   */
  excludeState: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles that mention or are related to specific counties. Accepts either a single county name or an array. Multiple values create an OR filter. County names typically include the word 'County' (e.g., Los Angeles County).
   */
  county: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles that mention or are related to specific counties. Accepts either a single county name or an array. Multiple values create an AND-exclude filter. County names should match the format in article metadata (e.g., Los Angeles County, Cook County).
   */
  excludeCounty: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles that mention or are related to specific cities. Accepts either a single city name or an array. Multiple values create an OR filter.
   */
  city: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles that mention or are related to specific cities. Accepts either a single city name or an array. Multiple values create an AND-exclude filter.
   */
  excludeCity: z.array(z.string()).optional().nullable(),
  /**
   * Filter for articles from publishers based in specific countries. Accepts either a single country code or an array. Uses two-letter country codes in lowercase (e.g., us, gb). See documentation for supported country codes.
   */
  sourceCountry: z.array(z.string()).optional().nullable(),
  /**
   * Filter for articles from publishers based in specific states or regions. Accepts either a single state code or an array. Uses two-letter state codes in lowercase. See documentation for supported state codes.
   */
  sourceState: z.array(z.string()).optional().nullable(),
  /**
   * Filter for articles from publishers based in specific counties. Accepts either a single county name or an array. Multiple values create an OR filter.
   */
  sourceCounty: z.array(z.string()).optional().nullable(),
  /**
   * Filter for articles from publishers based in specific cities. Accepts either a single city name or an array. Multiple values create an OR filter.
   */
  sourceCity: z.array(z.string()).optional().nullable(),
  coordinates: CoordinateFilterSchema.optional().nullable(),
  sourceCoordinates: CoordinateFilterSchema.optional().nullable(),
  /**
   * Filter articles by company identifiers. Accepts either a single ID or an array. Multiple values create an OR filter. For a complete list of tracked companies and their IDs, refer to the /companies endpoint.
   */
  companyId: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles mentioning companies with specific identifiers. Accepts either a single ID or an array. Multiple values create an AND-exclude filter. For a complete list of tracked companies and their IDs, refer to the /companies endpoint.
   */
  excludeCompanyId: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by company domains (e.g., apple.com). Accepts either a single domain or an array. Multiple values create an OR filter. For a complete list of tracked companies and their domains, refer to the /companies endpoint.
   */
  companyDomain: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles related to companies with specific domains. Accepts either a single domain or an array. Multiple values create an AND-exclude filter. For a complete list of tracked companies and their domains, refer to the /companies endpoint.
   */
  excludeCompanyDomain: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by company stock symbols (e.g., AAPL, MSFT). Accepts either a single symbol or an array. Multiple values create an OR filter. For a complete list of tracked companies and their symbols, refer to the /companies endpoint.
   */
  companySymbol: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles related to companies with specific stock symbols. Accepts either a single symbol or an array. Multiple values create an AND-exclude filter. For a complete list of tracked companies and their symbols, refer to the /companies endpoint.
   */
  excludeCompanySymbol: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by company name mentions. Accepts either a single name or an array. Performs exact matching on company names. Multiple values create an OR filter. For a complete list of tracked companies and their names, refer to the /companies endpoint.
   */
  companyName: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by Wikidata IDs of mentioned people. Accepts either a single ID or an array. Multiple values create an OR filter. For a complete list of tracked individuals and their Wikidata IDs, refer to the /people endpoint.
   */
  personWikidataId: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles mentioning people with specific Wikidata IDs. Accepts either a single ID or an array. Multiple values create an AND-exclude filter. For a complete list of tracked individuals and their Wikidata IDs, refer to the /people endpoint.
   */
  excludePersonWikidataId: z.array(z.string()).optional().nullable(),
  /**
   * Filter articles by exact person name matches. Accepts either a single name or an array. Does not support Boolean operators or wildcards. Multiple values create an OR filter. For a complete list of tracked individuals and their names, refer to the /people endpoint.
   */
  personName: z.array(z.string()).optional().nullable(),
  /**
   * Exclude articles mentioning specific people by name. Accepts either a single name or an array. Multiple values create an AND-exclude filter. For a complete list of tracked individuals and their names, refer to the /people endpoint.
   */
  excludePersonName: z.array(z.string()).optional().nullable(),
  /**
   * Adds additional AND filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the AND logical operator.
   */
  AND: z
    .array(z.unknown()) /* Self-reference prevented */
    .optional()
    .nullable(),
  /**
   * Adds additional OR filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the OR logical operator.
   */
  OR: z
    .array(z.unknown()) /* Self-reference prevented */
    .optional()
    .nullable(),
  /**
   * A filter object for logical NOT operations
   */
  NOT: z
    .array(z.unknown()) /* Self-reference prevented */
    .optional()
    .nullable(),
});

export type ArticleSearchFilter = z.infer<typeof ArticleSearchFilterSchema>;

export const ArticleSearchParamsSchema = z.object({
  /**
   * Natural language query to search the news articles database
   */
  prompt: z.string(),
  filter: ArticleSearchFilterSchema.optional().nullable(),
  /**
   * 'pubDateFrom' filter, will search articles published after the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00 - Default: Only articles with a pubDate within the last 30 days of the request
   */
  pubDateFrom: z
    .union([z.string().date(), z.string().datetime()])
    .transform((val) => new Date(val))
    .optional()
    .nullable(),
  /**
   * 'pubDateTo' filter, will search articles published before the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00
   */
  pubDateTo: z
    .union([z.string().date(), z.string().datetime()])
    .transform((val) => new Date(val))
    .optional()
    .nullable(),
  /**
   * Whether to return reprints in the response or not. Reprints are usually wired articles from sources like AP or Reuters that are reprinted in multiple sources at the same time. By default, this parameter is 'true'.
   */
  showReprints: z.boolean().optional().nullable(),
  /**
   * The number of items per page.
   */
  size: z.number().optional().nullable(),
  /**
   * The page number to retrieve.
   */
  page: z.number().optional().nullable(),
});

export type ArticleSearchParams = z.infer<typeof ArticleSearchParamsSchema>;

export const ScoredDataArticleSchema = z.object({
  score: z.number().optional().nullable(),
  data: ArticleSchema.optional().nullable(),
});

export type ScoredDataArticle = z.infer<typeof ScoredDataArticleSchema>;

export const ArticlesVectorSearchResultSchema = z.object({
  status: z.number(),
  results: z.array(ScoredDataArticleSchema),
});

export type ArticlesVectorSearchResult = z.infer<
  typeof ArticlesVectorSearchResultSchema
>;

export const SymbolHolderSchema = z.object({
  symbol: z.string().optional().nullable(),
  exchange: z.string().optional().nullable(),
  exchangeShortName: z.string().optional().nullable(),
  ipoDate: z.string().optional().nullable(),
});

export type SymbolHolder = z.infer<typeof SymbolHolderSchema>;

export const WebResourcesSchema = z.object({
  careers: z.string().optional().nullable(),
  about: z.string().optional().nullable(),
  blog: z.string().optional().nullable(),
  events: z.string().optional().nullable(),
  sitemap: z.string().optional().nullable(),
  updates: z.string().optional().nullable(),
  linkedin: z.string().optional().nullable(),
  facebook: z.string().optional().nullable(),
  instagram: z.string().optional().nullable(),
  medium: z.string().optional().nullable(),
  reddit: z.string().optional().nullable(),
  threads: z.string().optional().nullable(),
  tiktok: z.string().optional().nullable(),
  x: z.string().optional().nullable(),
  wellfound: z.string().optional().nullable(),
  youtube: z.string().optional().nullable(),
  wikipedia: z.string().optional().nullable(),
});

export type WebResources = z.infer<typeof WebResourcesSchema>;

export const CompanySchema = z.object({
  id: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  updatedAt: z.string().optional().nullable(),
  primaryRecordId: z.string().optional().nullable(),
  altNames: z.array(z.string()).optional().nullable(),
  domains: z.array(z.string()).optional().nullable(),
  monthlyVisits: z.number().optional().nullable(),
  globalRank: z.number().optional().nullable(),
  description: z.string().optional().nullable(),
  ceo: z.string().optional().nullable(),
  industry: z.string().optional().nullable(),
  sector: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  fullTimeEmployees: z.number().optional().nullable(),
  address: z.string().optional().nullable(),
  city: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  zip: z.string().optional().nullable(),
  logo: z.string().optional().nullable(),
  favicon: z.string().optional().nullable(),
  isEtf: z.boolean().optional().nullable(),
  isActivelyTrading: z.boolean().optional().nullable(),
  isFund: z.boolean().optional().nullable(),
  isAdr: z.boolean().optional().nullable(),
  symbols: z.array(SymbolHolderSchema).optional().nullable(),
  naics: z.string().optional().nullable(),
  sic: z.string().optional().nullable(),
  cusip: z.string().optional().nullable(),
  cik: z.string().optional().nullable(),
  isin: z.string().optional().nullable(),
  yearFounded: z.number().optional().nullable(),
  revenue: z.string().optional().nullable(),
  webResources: WebResourcesSchema.optional().nullable(),
});

export type Company = z.infer<typeof CompanySchema>;

export const CompanySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(CompanySchema),
});

export type CompanySearchResult = z.infer<typeof CompanySearchResultSchema>;

export const ErrorResponseSchema = z.object({
  status: z.number().optional().nullable(),
  message: z.string().optional().nullable(),
  timestamp: z.number().optional().nullable(),
});

export type ErrorResponse = z.infer<typeof ErrorResponseSchema>;

export const ImageHolderSchema = z.object({
  url: z.string().optional().nullable(),
});

export type ImageHolder = z.infer<typeof ImageHolderSchema>;

export const JournalistSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(JournalistSchema),
});

export type JournalistSearchResult = z.infer<
  typeof JournalistSearchResultSchema
>;

export const WikidataDateHolderSchema = z.object({
  time: z.string().optional().nullable(),
  precision: z.string().optional().nullable(),
});

export type WikidataDateHolder = z.infer<typeof WikidataDateHolderSchema>;

export const WikidataLabelHolderSchema = z.object({
  wikidataId: z.string().optional().nullable(),
  label: z.string().optional().nullable(),
});

export type WikidataLabelHolder = z.infer<typeof WikidataLabelHolderSchema>;

export const WikidataPoliticalPartyHolderSchema = z.object({
  wikidataId: z.string().optional().nullable(),
  label: z.string().optional().nullable(),
  startTime: WikidataDateHolderSchema.optional().nullable(),
  endTime: WikidataDateHolderSchema.optional().nullable(),
});

export type WikidataPoliticalPartyHolder = z.infer<
  typeof WikidataPoliticalPartyHolderSchema
>;

export const WikidataPositionHolderSchema = z.object({
  wikidataId: z.string().optional().nullable(),
  label: z.string().optional().nullable(),
  startTime: WikidataDateHolderSchema.optional().nullable(),
  endTime: WikidataDateHolderSchema.optional().nullable(),
  employer: WikidataLabelHolderSchema.optional().nullable(),
});

export type WikidataPositionHolder = z.infer<
  typeof WikidataPositionHolderSchema
>;

export const PersonSchema = z.object({
  wikidataId: z.string().optional().nullable(),
  createdAt: z.string().optional().nullable(),
  updatedAt: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  gender: WikidataLabelHolderSchema.optional().nullable(),
  dateOfBirth: WikidataDateHolderSchema.optional().nullable(),
  dateOfDeath: WikidataDateHolderSchema.optional().nullable(),
  description: z.string().optional().nullable(),
  aliases: z.array(z.string()).optional().nullable(),
  occupation: z.array(WikidataLabelHolderSchema).optional().nullable(),
  position: z.array(WikidataPositionHolderSchema).optional().nullable(),
  politicalParty: z
    .array(WikidataPoliticalPartyHolderSchema)
    .optional()
    .nullable(),
  image: ImageHolderSchema.optional().nullable(),
  _abstract: z.string().optional().nullable(),
});

export type Person = z.infer<typeof PersonSchema>;

export const PeopleSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(PersonSchema),
});

export type PeopleSearchResult = z.infer<typeof PeopleSearchResultSchema>;

export const QuerySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  articles: z.array(ArticleSchema),
});

export type QuerySearchResult = z.infer<typeof QuerySearchResultSchema>;

export const WikiDataSchema = z.object({
  pageId: z.string().optional().nullable(),
  sectionId: z.string().optional().nullable(),
  wikiPageId: z.number().optional().nullable(),
  wikiRevisionId: z.number().optional().nullable(),
  wikiRevisionTs: z.string().optional().nullable(),
  wikiCode: z.string().optional().nullable(),
  wikiNamespace: z.number().optional().nullable(),
  wikiTitle: z.string().optional().nullable(),
  wikidataId: z.string().optional().nullable(),
  wikidataInstanceOf: z.array(WikidataLabelHolderSchema).optional().nullable(),
  redirectTitles: z.array(z.string()).optional().nullable(),
  pageviews: z.number().optional().nullable(),
  title: z.string().optional().nullable(),
  styleLevel: z.number().optional().nullable(),
  content: z.string().optional().nullable(),
});

export type WikiData = z.infer<typeof WikiDataSchema>;

export const ScoredDataWikiDataSchema = z.object({
  score: z.number().optional().nullable(),
  data: WikiDataSchema.optional().nullable(),
});

export type ScoredDataWikiData = z.infer<typeof ScoredDataWikiDataSchema>;

export const SourceTopStatHolderSchema = z.object({
  name: z.string().optional().nullable(),
  count: z.number().optional().nullable(),
});

export type SourceTopStatHolder = z.infer<typeof SourceTopStatHolderSchema>;

export const SourceSchema = z.object({
  id: z.string().optional().nullable(),
  domain: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  primaryRecordId: z.string().optional().nullable(),
  updatedAt: z.string().optional().nullable(),
  altNames: z.array(z.string()).optional().nullable(),
  description: z.string().optional().nullable(),
  avgMonthlyPosts: z.number().optional().nullable(),
  paywall: z.boolean().optional().nullable(),
  location: SourceLocationSchema.optional().nullable(),
  topCategories: z.array(SourceTopStatHolderSchema).optional().nullable(),
  topTopics: z.array(SourceTopStatHolderSchema).optional().nullable(),
  topCountries: z.array(SourceTopStatHolderSchema).optional().nullable(),
  topLabels: z.array(SourceTopStatHolderSchema).optional().nullable(),
  avgBiasRating: z.string().optional().nullable(),
  adFontesBiasRating: z.string().optional().nullable(),
  allSidesBiasRating: z.string().optional().nullable(),
  mbfcBiasRating: z.string().optional().nullable(),
  monthlyVisits: z.number().optional().nullable(),
  globalRank: z.number().optional().nullable(),
  logoLarge: ImageHolderSchema.optional().nullable(),
  logoFavIcon: ImageHolderSchema.optional().nullable(),
  logoSquare: ImageHolderSchema.optional().nullable(),
});

export type Source = z.infer<typeof SourceSchema>;

export const SourceSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(SourceSchema),
});

export type SourceSearchResult = z.infer<typeof SourceSearchResultSchema>;

export const StatResultSchema = z.object({
  status: z.number().optional().nullable(),
  results: z.array(z.unknown()).optional().nullable(),
});

export type StatResult = z.infer<typeof StatResultSchema>;

export const StoryHistoryRecordSchema = z.object({
  clusterId: z.string().optional().nullable(),
  createdAt: z.string().optional().nullable(),
  name: z.string().optional().nullable(),
  triggeredAt: z.string().optional().nullable(),
  summary: z.string().optional().nullable(),
  shortSummary: z.string().optional().nullable(),
  changelog: z.string().optional().nullable(),
  keyPoints: z.array(KeyPointSchema).optional().nullable(),
  questions: z.array(QuestionSchema).optional().nullable(),
});

export type StoryHistoryRecord = z.infer<typeof StoryHistoryRecordSchema>;

export const StoryHistoryResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(StoryHistoryRecordSchema),
});

export type StoryHistoryResult = z.infer<typeof StoryHistoryResultSchema>;

export const StorySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(NewsClusterSchema),
});

export type StorySearchResult = z.infer<typeof StorySearchResultSchema>;

export const SummaryBodySchema = z.object({
  /**
   * Instructions guiding how the summary should be written. Maximum length: 2 048 characters.
   */
  prompt: z.string().optional().nullable(),
  /**
   * The maximum number of articles to factor into the summary.
   */
  maxArticleCount: z.number().optional().nullable(),
  /**
   * The maximum number of articles that should be returned in the response. This can be used to return fewer than maxArticleCount results.
   */
  returnedArticleCount: z.number().optional().nullable(),
  /**
   * Which article fields to include when generating the summary. Up to three values from TITLE, CONTENT, SUMMARY.
   */
  summarizeFields: z
    .enum(["TITLE", "CONTENT", "SUMMARY"])
    .optional()
    .nullable(),
  /**
   * Method for selecting articles: ARTICLES (include all matches) or CLUSTERS (one per cluster).
   */
  method: z.enum(["ARTICLES", "CLUSTERS"]).optional().nullable(),
  /**
   * The underlying LLM model to use for generation.
   */
  model: z
    .enum([
      "gpt-4o",
      "gpt-4o-mini",
      "gpt-4.1",
      "gpt-4.1-mini",
      "gpt-4.1-nano",
      "llama-3.3-70b-versatile",
      "deepseek-r1-distill-llama-70b",
    ])
    .optional()
    .nullable(),
  /**
   * Sampling temperature for the LLM (0.0 = deterministic to 2.0 = very creative).
   */
  temperature: z.number().optional().nullable(),
  /**
   * Nucleus sampling (top-p) for the LLM (0.0 to 1.0).
   */
  topP: z.number().optional().nullable(),
  /**
   * Maximum number of tokens to generate in the summary.
   */
  maxTokens: z.number().optional().nullable(),
});

export type SummaryBody = z.infer<typeof SummaryBodySchema>;

export const SummarySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  summary: z.string(),
  results: z.array(ArticleSchema),
});

export type SummarySearchResult = z.infer<typeof SummarySearchResultSchema>;

export const TopicLabelsSchema = z.object({
  category: z.string().optional().nullable(),
  subcategory: z.string().optional().nullable(),
});

export type TopicLabels = z.infer<typeof TopicLabelsSchema>;

export const TopicDtoSchema = z.object({
  id: z.number().optional().nullable(),
  createdAt: z
    .union([z.string().date(), z.string().datetime()])
    .transform((val) => new Date(val))
    .optional()
    .nullable(),
  updatedAt: z
    .union([z.string().date(), z.string().datetime()])
    .transform((val) => new Date(val))
    .optional()
    .nullable(),
  name: z.string().optional().nullable(),
  labels: TopicLabelsSchema.optional().nullable(),
});

export type TopicDto = z.infer<typeof TopicDtoSchema>;

export const TopicSearchResultSchema = z.object({
  total: z.number(),
  data: z.array(TopicDtoSchema),
});

export type TopicSearchResult = z.infer<typeof TopicSearchResultSchema>;

export const WikiPageSectionHolderSchema = z.object({
  id: z.string().optional().nullable(),
  title: z.string().optional().nullable(),
  styleLevel: z.number().optional().nullable(),
  loc: z.array(z.number()).optional().nullable(),
  textRaw: z.string().optional().nullable(),
  textRich: z.string().optional().nullable(),
});

export type WikiPageSectionHolder = z.infer<typeof WikiPageSectionHolderSchema>;

export const WikiPageSchema = z.object({
  id: z.string().optional().nullable(),
  scrapedAt: z.string().optional().nullable(),
  wikiPageId: z.number().optional().nullable(),
  wikiRevisionId: z.number().optional().nullable(),
  wikiRevisionTs: z.string().optional().nullable(),
  wikiCode: z.string().optional().nullable(),
  wikiNamespace: z.number().optional().nullable(),
  wikiTitle: z.string().optional().nullable(),
  url: z.string().optional().nullable(),
  topImage: z.string().optional().nullable(),
  wikidataId: z.string().optional().nullable(),
  wikidataInstanceOf: z.array(WikidataLabelHolderSchema).optional().nullable(),
  redirectTitles: z.array(z.string()).optional().nullable(),
  summary: z.string().optional().nullable(),
  sections: z.array(WikiPageSectionHolderSchema).optional().nullable(),
  categories: z.array(z.string()).optional().nullable(),
  externalLinks: z.array(z.string()).optional().nullable(),
  references: z.array(z.string()).optional().nullable(),
  pageviews: z.number().optional().nullable(),
});

export type WikiPage = z.infer<typeof WikiPageSchema>;

export const WikipediaSearchFilterSchema = z.object({
  /**
   * Filter by specific Perigon page identifiers. Accepts either a single ID or an array of IDs. Returns only pages matching these IDs.
   */
  pageId: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific section identifiers. Accepts either a single ID or an array of IDs. Returns only pages containing these sections.
   */
  sectionId: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific Wikipedia page identifiers. Accepts either a single ID or an array of IDs. Returns only pages matching these IDs.
   */
  wikiPageId: z.array(z.number()).optional().nullable(),
  /**
   * Filter by specific Perigon page revision identifiers. Accepts either a single ID or an array of IDs. Returns only pages matching these IDs.
   */
  wikiRevisionId: z.array(z.number()).optional().nullable(),
  /**
   * Filter by specific Wikipedia project codes. Returns only pages matching these projects.
   */
  wikiCode: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific Wikipedia namespaces. Returns only pages matching these namespaces.
   */
  wikiNamespace: z.array(z.number()).optional().nullable(),
  /**
   * Filter by specific Wikidata entity IDs. Returns only pages whose Wikidata entities match those ids.
   */
  wikidataId: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific Wikidata entity IDs. Returns only pages whose Wikidata entities are instances of provided ids.
   */
  wikidataInstanceOfId: z.array(z.string()).optional().nullable(),
  /**
   * Filter by specific Wikidata entity labels. Returns only pages whose Wikidata entities are instances of these labels.
   */
  wikidataInstanceOfLabel: z.array(z.string()).optional().nullable(),
  /**
   * Adds additional AND filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the AND logical operator.
   */
  AND: z
    .array(z.unknown()) /* Self-reference prevented */
    .optional()
    .nullable(),
  /**
   * Adds additional OR filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the OR logical operator.
   */
  OR: z
    .array(z.unknown()) /* Self-reference prevented */
    .optional()
    .nullable(),
  /**
   * A filter object for logical NOT operations
   */
  NOT: z
    .array(z.unknown()) /* Self-reference prevented */
    .optional()
    .nullable(),
});

export type WikipediaSearchFilter = z.infer<typeof WikipediaSearchFilterSchema>;

export const WikipediaSearchParamsSchema = z.object({
  /**
   * Natural language query to search the Wikipedia pages database
   */
  prompt: z.string(),
  filter: WikipediaSearchFilterSchema.optional().nullable(),
  /**
   * 'wikiRevisionFrom' filter, will search pages modified after the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00.
   */
  wikiRevisionFrom: z
    .union([z.string().date(), z.string().datetime()])
    .transform((val) => new Date(val))
    .optional()
    .nullable(),
  /**
   * 'wikiRevisionFrom' filter, will search pages modified before the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00.
   */
  wikiRevisionTo: z
    .union([z.string().date(), z.string().datetime()])
    .transform((val) => new Date(val))
    .optional()
    .nullable(),
  /**
   * 'pageviewsFrom' filter, will search pages with at least the provided number of views per day.
   */
  pageviewsFrom: z.number().optional().nullable(),
  /**
   * 'pageviewsFrom' filter, will search pages with at most the provided number of views per day.
   */
  pageviewsTo: z.number().optional().nullable(),
  /**
   * The number of items per page.
   */
  size: z.number().optional().nullable(),
  /**
   * The page number to retrieve.
   */
  page: z.number().optional().nullable(),
});

export type WikipediaSearchParams = z.infer<typeof WikipediaSearchParamsSchema>;

export const WikipediaSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(WikiPageSchema),
});

export type WikipediaSearchResult = z.infer<typeof WikipediaSearchResultSchema>;

export const WikipediaVectorSearchResultSchema = z.object({
  status: z.number(),
  results: z.array(ScoredDataWikiDataSchema),
});

export type WikipediaVectorSearchResult = z.infer<
  typeof WikipediaVectorSearchResultSchema
>;
