/**
 * Perigon API
 * The Perigon API provides access to comprehensive news and web content data. To use the API, simply sign up for a Perigon Business Solutions account to obtain your API key. Your available features may vary based on your plan. See the Authentication section for details on how to use your API key.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: data@perigon.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { z } from "zod";

export const AllEndpointSortBySchema = z.enum([
  "relevance",
  "date",
  "reverseDate",
  "reverseAddDate",
  "addDate",
  "pubDate",
  "refreshDate",
]);

export type AllEndpointSortBy = z.infer<typeof AllEndpointSortBySchema>;

export const AllEndpointSortBy = {
  Relevance: "relevance",
  Date: "date",
  ReverseDate: "reverseDate",
  ReverseAddDate: "reverseAddDate",
  AddDate: "addDate",
  PubDate: "pubDate",
  RefreshDate: "refreshDate",
} as const;

export const ArticleSchema = z.object({
  url: z.string().optional(),
  authorsByline: z.string().optional(),
  articleId: z.string().optional(),
  clusterId: z.string().optional(),
  source: z.unknown().optional(),
  imageUrl: z.string().optional(),
  country: z.string().optional(),
  language: z.string().optional(),
  pubDate: z.string().optional(),
  addDate: z.string().optional(),
  refreshDate: z.string().optional(),
  score: z.number().optional(),
  title: z.string().optional(),
  description: z.string().optional(),
  content: z.string().optional(),
  medium: z.string().optional(),
  links: z.array(z.string()).default([]),
  labels: z.array(z.unknown()).default([]),
  eventTypes: z.array(z.unknown()).default([]),
  matchedAuthors: z.array(z.unknown()).default([]),
  claim: z.string().optional(),
  verdict: z.string().optional(),
  keywords: z.array(z.unknown()).default([]),
  topics: z.array(z.unknown()).default([]),
  categories: z.array(z.unknown()).default([]),
  taxonomies: z.array(z.unknown()).default([]),
  entities: z.array(z.unknown()).default([]),
  companies: z.array(z.unknown()).default([]),
  sentiment: z.unknown().optional(),
  summary: z.string().optional(),
  shortSummary: z.string().optional(),
  translation: z.string().optional(),
  translatedTitle: z.string().optional(),
  translatedDescription: z.string().optional(),
  translatedSummary: z.string().optional(),
  locations: z.array(z.unknown()).default([]),
  reprint: z.boolean().optional(),
  reprintGroupId: z.string().optional(),
  places: z.array(z.unknown()).default([]),
  people: z.array(z.unknown()).default([]),
  cluster: z.unknown().optional(),
  journalists: z.array(z.unknown()).default([]),
  highlights: z.record(z.string(), z.array(z.string())).optional(),
});

export type Article = z.infer<typeof ArticleSchema>;

/**
 * Complex filter structure for article searches that supports nested logical operations (AND, OR, NOT) and multiple filtering criteria.
 * @export
 */
export const ArticleSearchFilterSchema = z.object({
  /**
   * Filter by specific article identifiers. Accepts either a single ID or an array of IDs. Returns only articles matching these IDs.
   */
  articleId: z.array(z.string()).default([]),
  /**
   * Filter by specific story identifiers. Accepts either a single ID or an array of IDs. Returns only articles belonging to these stories.
   */
  clusterId: z.array(z.string()).default([]),
  /**
   * Filter articles by specific publisher domains or subdomains. Accepts either a single domain or an array of domains. Multiple values create an OR filter.
   */
  source: z.array(z.string()).default([]),
  /**
   * Exclude articles from specific publisher domains or subdomains. Accepts either a single domain or an array of domains. Multiple values create an AND-exclude filter.
   */
  excludeSource: z.array(z.string()).default([]),
  /**
   * Filter articles using Perigon's curated publisher bundles (e.g., top100, top25tech). Accepts either a single source group or an array. Multiple values create an OR filter to include articles from any of the specified bundles.
   */
  sourceGroup: z.array(z.string()).default([]),
  /**
   * Filter articles by their language using ISO-639 two-letter codes in lowercase (e.g., en, es, fr). Accepts either a single language code or an array. Multiple values create an OR filter.
   */
  language: z.array(z.string()).default([]),
  /**
   * Exclude articles in specific languages using ISO-639 two-letter codes in lowercase. Accepts either a single language code or an array. Multiple values create an AND-exclude filter.
   */
  excludeLanguage: z.array(z.string()).default([]),
  /**
   * Filter articles by editorial labels such as Opinion, Paid-news, Non-news, Fact Check, or Press Release. View our docs for an exhaustive list of labels. Accepts either a single label or an array. Multiple values create an OR filter.
   */
  label: z.array(z.string()).default([]),
  /**
   * Exclude articles with specific editorial labels. Accepts either a single label or an array. Multiple values create an AND-exclude filter, removing all content with any of these labels.
   */
  excludeLabel: z.array(z.string()).default([]),
  /**
   * Filter by Google Content Categories. Must pass the full hierarchical path of the category. Accepts either a single path or an array. Example: taxonomy=/Finance/Banking/Other,/Finance/Investing/Funds. Multiple values create an OR filter.
   */
  taxonomy: z.array(z.string()).default([]),
  /**
   * Filter by broad content categories such as Politics, Tech, Sports, Business, or Finance. Accepts either a single category or an array. Use none to find uncategorized articles. Multiple values create an OR filter.
   */
  category: z.array(z.string()).default([]),
  /**
   * Filter by specific topics such as Markets, Crime, Cryptocurrency, or College Sports. Accepts either a single topic or an array. Topics are more granular than categories, and articles can have multiple topics. Multiple values create an OR filter.
   */
  topic: z.array(z.string()).default([]),
  /**
   * Exclude articles with specific topics. Accepts either a single topic or an array. Multiple values create an AND-exclude filter, removing all content with any of these topics.
   */
  excludeTopic: z.array(z.string()).default([]),
  /**
   * Filter articles by countries they mention using two-letter country codes in lowercase (e.g., us, gb, jp). Accepts either a single country code or an array. Multiple values create an OR filter. See documentation for supported country codes.
   */
  country: z.array(z.string()).default([]),
  /**
   * Exclude articles from specific countries using two-letter country codes in lowercase. Accepts either a single country code or an array. Multiple values create an AND-exclude filter. See documentation for supported country codes.
   */
  excludeCountry: z.array(z.string()).default([]),
  /**
   * Filter articles where specified countries play a central role in the content, not just mentioned. Uses two-letter country codes in lowercase. Accepts either a single country code or an array. Multiple values create an OR filter. See documentation for supported country codes.
   */
  locationsCountry: z.array(z.string()).default([]),
  /**
   * Exclude articles where specified countries play a central role in the content. Accepts either a single country code or an array. Multiple values create an AND-exclude filter, removing articles focused on any of these countries. See documentation for supported country codes.
   */
  excludeLocationsCountry: z.array(z.string()).default([]),
  /**
   * Filter articles where specified states play a central role in the content. Accepts either a single state code or an array. Multiple values create an OR filter. Uses two-letter state codes in lowercase. See documentation for supported state codes.
   */
  state: z.array(z.string()).default([]),
  /**
   * Exclude articles where specified states play a central role. Accepts either a single state code or an array. Multiple values create an AND-exclude filter, removing articles focused on any of these states. See documentation for supported state codes.
   */
  excludeState: z.array(z.string()).default([]),
  /**
   * Filter articles that mention or are related to specific counties. Accepts either a single county name or an array. Multiple values create an OR filter. County names typically include the word 'County' (e.g., Los Angeles County).
   */
  county: z.array(z.string()).default([]),
  /**
   * Exclude articles that mention or are related to specific counties. Accepts either a single county name or an array. Multiple values create an AND-exclude filter. County names should match the format in article metadata (e.g., Los Angeles County, Cook County).
   */
  excludeCounty: z.array(z.string()).default([]),
  /**
   * Filter articles that mention or are related to specific cities. Accepts either a single city name or an array. Multiple values create an OR filter.
   */
  city: z.array(z.string()).default([]),
  /**
   * Exclude articles that mention or are related to specific cities. Accepts either a single city name or an array. Multiple values create an AND-exclude filter.
   */
  excludeCity: z.array(z.string()).default([]),
  /**
   * Filter for articles from publishers based in specific countries. Accepts either a single country code or an array. Uses two-letter country codes in lowercase (e.g., us, gb). See documentation for supported country codes.
   */
  sourceCountry: z.array(z.string()).default([]),
  /**
   * Filter for articles from publishers based in specific states or regions. Accepts either a single state code or an array. Uses two-letter state codes in lowercase. See documentation for supported state codes.
   */
  sourceState: z.array(z.string()).default([]),
  /**
   * Filter for articles from publishers based in specific counties. Accepts either a single county name or an array. Multiple values create an OR filter.
   */
  sourceCounty: z.array(z.string()).default([]),
  /**
   * Filter for articles from publishers based in specific cities. Accepts either a single city name or an array. Multiple values create an OR filter.
   */
  sourceCity: z.array(z.string()).default([]),
  coordinates: z.unknown().optional(),
  sourceCoordinates: z.unknown().optional(),
  /**
   * Filter articles by company identifiers. Accepts either a single ID or an array. Multiple values create an OR filter. For a complete list of tracked companies and their IDs, refer to the /companies endpoint.
   */
  companyId: z.array(z.string()).default([]),
  /**
   * Exclude articles mentioning companies with specific identifiers. Accepts either a single ID or an array. Multiple values create an AND-exclude filter. For a complete list of tracked companies and their IDs, refer to the /companies endpoint.
   */
  excludeCompanyId: z.array(z.string()).default([]),
  /**
   * Filter articles by company domains (e.g., apple.com). Accepts either a single domain or an array. Multiple values create an OR filter. For a complete list of tracked companies and their domains, refer to the /companies endpoint.
   */
  companyDomain: z.array(z.string()).default([]),
  /**
   * Exclude articles related to companies with specific domains. Accepts either a single domain or an array. Multiple values create an AND-exclude filter. For a complete list of tracked companies and their domains, refer to the /companies endpoint.
   */
  excludeCompanyDomain: z.array(z.string()).default([]),
  /**
   * Filter articles by company stock symbols (e.g., AAPL, MSFT). Accepts either a single symbol or an array. Multiple values create an OR filter. For a complete list of tracked companies and their symbols, refer to the /companies endpoint.
   */
  companySymbol: z.array(z.string()).default([]),
  /**
   * Exclude articles related to companies with specific stock symbols. Accepts either a single symbol or an array. Multiple values create an AND-exclude filter. For a complete list of tracked companies and their symbols, refer to the /companies endpoint.
   */
  excludeCompanySymbol: z.array(z.string()).default([]),
  /**
   * Filter articles by company name mentions. Accepts either a single name or an array. Performs exact matching on company names. Multiple values create an OR filter. For a complete list of tracked companies and their names, refer to the /companies endpoint.
   */
  companyName: z.array(z.string()).default([]),
  /**
   * Filter articles by Wikidata IDs of mentioned people. Accepts either a single ID or an array. Multiple values create an OR filter. For a complete list of tracked individuals and their Wikidata IDs, refer to the /people endpoint.
   */
  personWikidataId: z.array(z.string()).default([]),
  /**
   * Exclude articles mentioning people with specific Wikidata IDs. Accepts either a single ID or an array. Multiple values create an AND-exclude filter. For a complete list of tracked individuals and their Wikidata IDs, refer to the /people endpoint.
   */
  excludePersonWikidataId: z.array(z.string()).default([]),
  /**
   * Filter articles by exact person name matches. Accepts either a single name or an array. Does not support Boolean operators or wildcards. Multiple values create an OR filter. For a complete list of tracked individuals and their names, refer to the /people endpoint.
   */
  personName: z.array(z.string()).default([]),
  /**
   * Exclude articles mentioning specific people by name. Accepts either a single name or an array. Multiple values create an AND-exclude filter. For a complete list of tracked individuals and their names, refer to the /people endpoint.
   */
  excludePersonName: z.array(z.string()).default([]),
  /**
   * Adds additional AND filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the AND logical operator.
   */
  aND: z.array(z.unknown()).default([]),
  /**
   * Adds additional OR filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the OR logical operator.
   */
  oR: z.array(z.unknown()).default([]),
  /**
   * A filter object for logical NOT operations
   */
  nOT: z.array(z.unknown()).default([]),
});

export type ArticleSearchFilter = z.infer<typeof ArticleSearchFilterSchema>;

export const ArticleSearchParamsSchema = z.object({
  /**
   * Natural language query to search the news articles database
   */
  prompt: z.string(),
  filter: z.unknown().optional(),
  /**
   * 'pubDateFrom' filter, will search articles published after the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00 - Default: Only articles with a pubDate within the last 30 days of the request
   */
  pubDateFrom: z.string().optional(),
  /**
   * 'pubDateFrom' filter, will search articles published before the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00
   */
  pubDateTo: z.string().optional(),
  /**
   * Whether to return reprints in the response or not. Reprints are usually wired articles from sources like AP or Reuters that are reprinted in multiple sources at the same time. By default, this parameter is 'true'.
   */
  showReprints: z.boolean().optional(),
  /**
   * The number of items per page.
   */
  size: z.number().optional(),
  /**
   * The page number to retrieve.
   */
  page: z.number().optional(),
});

export type ArticleSearchParams = z.infer<typeof ArticleSearchParamsSchema>;

/**
 * Articles vector search result
 * @export
 */
export const ArticlesVectorSearchResultSchema = z.object({
  status: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type ArticlesVectorSearchResult = z.infer<
  typeof ArticlesVectorSearchResultSchema
>;

export const AuthExceptionSchema = z.object({
  cause: z.unknown().optional(),
  stackTrace: z.array(z.unknown()).default([]),
  statusCode: z
    .enum([
      "100 CONTINUE",
      "101 SWITCHING_PROTOCOLS",
      "102 PROCESSING",
      "103 CHECKPOINT",
      "200 OK",
      "201 CREATED",
      "202 ACCEPTED",
      "203 NON_AUTHORITATIVE_INFORMATION",
      "204 NO_CONTENT",
      "205 RESET_CONTENT",
      "206 PARTIAL_CONTENT",
      "207 MULTI_STATUS",
      "208 ALREADY_REPORTED",
      "226 IM_USED",
      "300 MULTIPLE_CHOICES",
      "301 MOVED_PERMANENTLY",
      "302 FOUND",
      "302 MOVED_TEMPORARILY",
      "303 SEE_OTHER",
      "304 NOT_MODIFIED",
      "305 USE_PROXY",
      "307 TEMPORARY_REDIRECT",
      "308 PERMANENT_REDIRECT",
      "400 BAD_REQUEST",
      "401 UNAUTHORIZED",
      "402 PAYMENT_REQUIRED",
      "403 FORBIDDEN",
      "404 NOT_FOUND",
      "405 METHOD_NOT_ALLOWED",
      "406 NOT_ACCEPTABLE",
      "407 PROXY_AUTHENTICATION_REQUIRED",
      "408 REQUEST_TIMEOUT",
      "409 CONFLICT",
      "410 GONE",
      "411 LENGTH_REQUIRED",
      "412 PRECONDITION_FAILED",
      "413 PAYLOAD_TOO_LARGE",
      "413 REQUEST_ENTITY_TOO_LARGE",
      "414 URI_TOO_LONG",
      "414 REQUEST_URI_TOO_LONG",
      "415 UNSUPPORTED_MEDIA_TYPE",
      "416 REQUESTED_RANGE_NOT_SATISFIABLE",
      "417 EXPECTATION_FAILED",
      "418 I_AM_A_TEAPOT",
      "419 INSUFFICIENT_SPACE_ON_RESOURCE",
      "420 METHOD_FAILURE",
      "421 DESTINATION_LOCKED",
      "422 UNPROCESSABLE_ENTITY",
      "423 LOCKED",
      "424 FAILED_DEPENDENCY",
      "425 TOO_EARLY",
      "426 UPGRADE_REQUIRED",
      "428 PRECONDITION_REQUIRED",
      "429 TOO_MANY_REQUESTS",
      "431 REQUEST_HEADER_FIELDS_TOO_LARGE",
      "451 UNAVAILABLE_FOR_LEGAL_REASONS",
      "500 INTERNAL_SERVER_ERROR",
      "501 NOT_IMPLEMENTED",
      "502 BAD_GATEWAY",
      "503 SERVICE_UNAVAILABLE",
      "504 GATEWAY_TIMEOUT",
      "505 HTTP_VERSION_NOT_SUPPORTED",
      "506 VARIANT_ALSO_NEGOTIATES",
      "507 INSUFFICIENT_STORAGE",
      "508 LOOP_DETECTED",
      "509 BANDWIDTH_LIMIT_EXCEEDED",
      "510 NOT_EXTENDED",
      "511 NETWORK_AUTHENTICATION_REQUIRED",
    ])
    .optional(),
  message: z.string().optional(),
  suppressed: z.array(z.unknown()).default([]),
  localizedMessage: z.string().optional(),
});

export type AuthException = z.infer<typeof AuthExceptionSchema>;

/**
 * @export
 */
export const AuthExceptionStatusCodeEnum = {
  _100Continue: "100 CONTINUE",
  _101SwitchingProtocols: "101 SWITCHING_PROTOCOLS",
  _102Processing: "102 PROCESSING",
  _103Checkpoint: "103 CHECKPOINT",
  _200Ok: "200 OK",
  _201Created: "201 CREATED",
  _202Accepted: "202 ACCEPTED",
  _203NonAuthoritativeInformation: "203 NON_AUTHORITATIVE_INFORMATION",
  _204NoContent: "204 NO_CONTENT",
  _205ResetContent: "205 RESET_CONTENT",
  _206PartialContent: "206 PARTIAL_CONTENT",
  _207MultiStatus: "207 MULTI_STATUS",
  _208AlreadyReported: "208 ALREADY_REPORTED",
  _226ImUsed: "226 IM_USED",
  _300MultipleChoices: "300 MULTIPLE_CHOICES",
  _301MovedPermanently: "301 MOVED_PERMANENTLY",
  _302Found: "302 FOUND",
  _302MovedTemporarily: "302 MOVED_TEMPORARILY",
  _303SeeOther: "303 SEE_OTHER",
  _304NotModified: "304 NOT_MODIFIED",
  _305UseProxy: "305 USE_PROXY",
  _307TemporaryRedirect: "307 TEMPORARY_REDIRECT",
  _308PermanentRedirect: "308 PERMANENT_REDIRECT",
  _400BadRequest: "400 BAD_REQUEST",
  _401Unauthorized: "401 UNAUTHORIZED",
  _402PaymentRequired: "402 PAYMENT_REQUIRED",
  _403Forbidden: "403 FORBIDDEN",
  _404NotFound: "404 NOT_FOUND",
  _405MethodNotAllowed: "405 METHOD_NOT_ALLOWED",
  _406NotAcceptable: "406 NOT_ACCEPTABLE",
  _407ProxyAuthenticationRequired: "407 PROXY_AUTHENTICATION_REQUIRED",
  _408RequestTimeout: "408 REQUEST_TIMEOUT",
  _409Conflict: "409 CONFLICT",
  _410Gone: "410 GONE",
  _411LengthRequired: "411 LENGTH_REQUIRED",
  _412PreconditionFailed: "412 PRECONDITION_FAILED",
  _413PayloadTooLarge: "413 PAYLOAD_TOO_LARGE",
  _413RequestEntityTooLarge: "413 REQUEST_ENTITY_TOO_LARGE",
  _414UriTooLong: "414 URI_TOO_LONG",
  _414RequestUriTooLong: "414 REQUEST_URI_TOO_LONG",
  _415UnsupportedMediaType: "415 UNSUPPORTED_MEDIA_TYPE",
  _416RequestedRangeNotSatisfiable: "416 REQUESTED_RANGE_NOT_SATISFIABLE",
  _417ExpectationFailed: "417 EXPECTATION_FAILED",
  _418IAmATeapot: "418 I_AM_A_TEAPOT",
  _419InsufficientSpaceOnResource: "419 INSUFFICIENT_SPACE_ON_RESOURCE",
  _420MethodFailure: "420 METHOD_FAILURE",
  _421DestinationLocked: "421 DESTINATION_LOCKED",
  _422UnprocessableEntity: "422 UNPROCESSABLE_ENTITY",
  _423Locked: "423 LOCKED",
  _424FailedDependency: "424 FAILED_DEPENDENCY",
  _425TooEarly: "425 TOO_EARLY",
  _426UpgradeRequired: "426 UPGRADE_REQUIRED",
  _428PreconditionRequired: "428 PRECONDITION_REQUIRED",
  _429TooManyRequests: "429 TOO_MANY_REQUESTS",
  _431RequestHeaderFieldsTooLarge: "431 REQUEST_HEADER_FIELDS_TOO_LARGE",
  _451UnavailableForLegalReasons: "451 UNAVAILABLE_FOR_LEGAL_REASONS",
  _500InternalServerError: "500 INTERNAL_SERVER_ERROR",
  _501NotImplemented: "501 NOT_IMPLEMENTED",
  _502BadGateway: "502 BAD_GATEWAY",
  _503ServiceUnavailable: "503 SERVICE_UNAVAILABLE",
  _504GatewayTimeout: "504 GATEWAY_TIMEOUT",
  _505HttpVersionNotSupported: "505 HTTP_VERSION_NOT_SUPPORTED",
  _506VariantAlsoNegotiates: "506 VARIANT_ALSO_NEGOTIATES",
  _507InsufficientStorage: "507 INSUFFICIENT_STORAGE",
  _508LoopDetected: "508 LOOP_DETECTED",
  _509BandwidthLimitExceeded: "509 BANDWIDTH_LIMIT_EXCEEDED",
  _510NotExtended: "510 NOT_EXTENDED",
  _511NetworkAuthenticationRequired: "511 NETWORK_AUTHENTICATION_REQUIRED",
} as const;
export type AuthExceptionStatusCodeEnum =
  (typeof AuthExceptionStatusCodeEnum)[keyof typeof AuthExceptionStatusCodeEnum];

export const AuthExceptionCauseSchema = z.object({
  stackTrace: z.array(z.unknown()).default([]),
  message: z.string().optional(),
  localizedMessage: z.string().optional(),
});

export type AuthExceptionCause = z.infer<typeof AuthExceptionCauseSchema>;

export const AuthExceptionCauseStackTraceInnerSchema = z.object({
  classLoaderName: z.string().optional(),
  moduleName: z.string().optional(),
  moduleVersion: z.string().optional(),
  methodName: z.string().optional(),
  fileName: z.string().optional(),
  lineNumber: z.number().optional(),
  nativeMethod: z.boolean().optional(),
  className: z.string().optional(),
});

export type AuthExceptionCauseStackTraceInner = z.infer<
  typeof AuthExceptionCauseStackTraceInnerSchema
>;

export const AuthExceptionSuppressedInnerSchema = z.object({
  stackTrace: z.array(z.unknown()).default([]),
  message: z.string().optional(),
  localizedMessage: z.string().optional(),
});

export type AuthExceptionSuppressedInner = z.infer<
  typeof AuthExceptionSuppressedInnerSchema
>;

export const CategoryHolderSchema = z.object({
  name: z.string().optional(),
});

export type CategoryHolder = z.infer<typeof CategoryHolderSchema>;

export const CategoryWithScoreHolderSchema = z.object({
  name: z.string().optional(),
  score: z.number().optional(),
});

export type CategoryWithScoreHolder = z.infer<
  typeof CategoryWithScoreHolderSchema
>;

export const CompanySchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
  updatedAt: z.string().optional(),
  primaryRecordId: z.string().optional(),
  altNames: z.array(z.string()).default([]),
  domains: z.array(z.string()).default([]),
  monthlyVisits: z.number().optional(),
  globalRank: z.number().optional(),
  description: z.string().optional(),
  ceo: z.string().optional(),
  industry: z.string().optional(),
  sector: z.string().optional(),
  country: z.string().optional(),
  fullTimeEmployees: z.number().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip: z.string().optional(),
  logo: z.string().optional(),
  favicon: z.string().optional(),
  isEtf: z.boolean().optional(),
  isActivelyTrading: z.boolean().optional(),
  isFund: z.boolean().optional(),
  isAdr: z.boolean().optional(),
  symbols: z.array(z.unknown()).default([]),
  naics: z.string().optional(),
  sic: z.string().optional(),
  yearFounded: z.number().optional(),
  revenue: z.string().optional(),
  webResources: z.unknown().optional(),
});

export type Company = z.infer<typeof CompanySchema>;

export const CompanyCountSchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
  domains: z.array(z.string()).default([]),
  symbols: z.array(z.string()).default([]),
  count: z.number().optional(),
});

export type CompanyCount = z.infer<typeof CompanyCountSchema>;

export const CompanyHolderSchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
  domains: z.array(z.string()).default([]),
  symbols: z.array(z.string()).default([]),
});

export type CompanyHolder = z.infer<typeof CompanyHolderSchema>;

/**
 * Company search result
 * @export
 */
export const CompanySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type CompanySearchResult = z.infer<typeof CompanySearchResultSchema>;

export const CoordinateSchema = z.object({
  lat: z.number().optional(),
  lon: z.number().optional(),
});

export type Coordinate = z.infer<typeof CoordinateSchema>;

/**
 * Filter articles from publishers based at specific geographic locations. Uses latitude, longitude, and radius parameters to define a circular search area for publisher locations.
 * @export
 */
export const CoordinateFilterSchema = z.object({
  lat: z.number().optional(),
  lon: z.number().optional(),
  radius: z.number().optional(),
});

export type CoordinateFilter = z.infer<typeof CoordinateFilterSchema>;

export const EntityHolderSchema = z.object({
  data: z.string().optional(),
  type: z.string().optional(),
  mentions: z.number().optional(),
});

export type EntityHolder = z.infer<typeof EntityHolderSchema>;

export const EventTypeHolderSchema = z.object({
  name: z.string().optional(),
  type: z.string().optional(),
});

export type EventTypeHolder = z.infer<typeof EventTypeHolderSchema>;

export const IdNameHolderSchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
});

export type IdNameHolder = z.infer<typeof IdNameHolderSchema>;

export const IllegalParameterExceptionSchema = z.object({
  cause: z.unknown().optional(),
  stackTrace: z.array(z.unknown()).default([]),
  message: z.string().optional(),
  suppressed: z.array(z.unknown()).default([]),
  localizedMessage: z.string().optional(),
});

export type IllegalParameterException = z.infer<
  typeof IllegalParameterExceptionSchema
>;

export const ImageHolderSchema = z.object({
  url: z.string().optional(),
});

export type ImageHolder = z.infer<typeof ImageHolderSchema>;

export const InternalErrorExceptionSchema = z.object({
  cause: z.unknown().optional(),
  stackTrace: z.array(z.unknown()).default([]),
  message: z.string().optional(),
  suppressed: z.array(z.unknown()).default([]),
  localizedMessage: z.string().optional(),
});

export type InternalErrorException = z.infer<
  typeof InternalErrorExceptionSchema
>;

export const JournalistSchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
  fullName: z.string().optional(),
  headline: z.string().optional(),
  description: z.string().optional(),
  title: z.string().optional(),
  locations: z.array(z.unknown()).default([]),
  updatedAt: z.string().optional(),
  topTopics: z.array(z.unknown()).default([]),
  topSources: z.array(z.unknown()).default([]),
  topCategories: z.array(z.unknown()).default([]),
  topLabels: z.array(z.unknown()).default([]),
  topCountries: z.array(z.unknown()).default([]),
  avgMonthlyPosts: z.number().optional(),
  twitterHandle: z.string().optional(),
  twitterBio: z.string().optional(),
  imageUrl: z.string().optional(),
  linkedinUrl: z.string().optional(),
  linkedinConnections: z.number().optional(),
  linkedinFollowers: z.number().optional(),
  facebookUrl: z.string().optional(),
  instagramUrl: z.string().optional(),
  websiteUrl: z.string().optional(),
  blogUrl: z.string().optional(),
  tumblrUrl: z.string().optional(),
  youtubeUrl: z.string().optional(),
});

export type Journalist = z.infer<typeof JournalistSchema>;

/**
 * Journalist search result
 * @export
 */
export const JournalistSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type JournalistSearchResult = z.infer<
  typeof JournalistSearchResultSchema
>;

export const KeyPointSchema = z.object({
  point: z.string().optional(),
  references: z.array(z.string()).default([]),
});

export type KeyPoint = z.infer<typeof KeyPointSchema>;

export const KeywordHolderSchema = z.object({
  name: z.string().optional(),
  weight: z.number().optional(),
});

export type KeywordHolder = z.infer<typeof KeywordHolderSchema>;

export const LabelHolderSchema = z.object({
  name: z.string().optional(),
});

export type LabelHolder = z.infer<typeof LabelHolderSchema>;

export const LocationCountSchema = z.object({
  state: z.string().optional(),
  county: z.string().optional(),
  city: z.string().optional(),
  area: z.string().optional(),
  count: z.number().optional(),
});

export type LocationCount = z.infer<typeof LocationCountSchema>;

export const LocationHolderSchema = z.object({
  country: z.string().optional(),
  state: z.string().optional(),
  county: z.string().optional(),
  city: z.string().optional(),
  area: z.string().optional(),
});

export type LocationHolder = z.infer<typeof LocationHolderSchema>;

export const NameCountSchema = z.object({
  name: z.string().optional(),
  count: z.number().optional(),
});

export type NameCount = z.infer<typeof NameCountSchema>;

export const NewsClusterSchema = z.object({
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
  initializedAt: z.string().optional(),
  id: z.string().optional(),
  duplicateOf: z.string().optional(),
  slug: z.string().optional(),
  name: z.string().optional(),
  summary: z.string().optional(),
  shortSummary: z.string().optional(),
  summaryReferences: z.array(z.string()).default([]),
  imageSource: z.unknown().optional(),
  imageUrl: z.string().optional(),
  keyPoints: z.array(z.unknown()).default([]),
  questions: z.array(z.unknown()).default([]),
  uniqueSources: z.array(z.string()).default([]),
  selectedArticles: z.array(z.unknown()).default([]),
  sentiment: z.unknown().optional(),
  uniqueCount: z.number().optional(),
  reprintCount: z.number().optional(),
  totalCount: z.number().optional(),
  countries: z.array(z.unknown()).default([]),
  topCountries: z.array(z.string()).default([]),
  topics: z.array(z.unknown()).default([]),
  topTopics: z.array(z.unknown()).default([]),
  categories: z.array(z.unknown()).default([]),
  topCategories: z.array(z.unknown()).default([]),
  taxonomies: z.array(z.unknown()).default([]),
  topTaxonomies: z.array(z.unknown()).default([]),
  people: z.array(z.unknown()).default([]),
  topPeople: z.array(z.unknown()).default([]),
  companies: z.array(z.unknown()).default([]),
  topCompanies: z.array(z.unknown()).default([]),
  locations: z.array(z.unknown()).default([]),
  topLocations: z.array(z.unknown()).default([]),
  highlights: z.record(z.string(), z.array(z.string())).optional(),
});

export type NewsCluster = z.infer<typeof NewsClusterSchema>;

export const NotFoundExceptionSchema = z.object({
  cause: z.unknown().optional(),
  stackTrace: z.array(z.unknown()).default([]),
  message: z.string().optional(),
  suppressed: z.array(z.unknown()).default([]),
  localizedMessage: z.string().optional(),
});

export type NotFoundException = z.infer<typeof NotFoundExceptionSchema>;

/**
 * Person search result
 * @export
 */
export const PeopleSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type PeopleSearchResult = z.infer<typeof PeopleSearchResultSchema>;

export const PersonSchema = z.object({
  wikidataId: z.string().optional(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
  name: z.string().optional(),
  gender: z.unknown().optional(),
  dateOfBirth: z.unknown().optional(),
  dateOfDeath: z.unknown().optional(),
  description: z.string().optional(),
  aliases: z.array(z.string()).default([]),
  occupation: z.array(z.unknown()).default([]),
  position: z.array(z.unknown()).default([]),
  politicalParty: z.array(z.unknown()).default([]),
  image: z.unknown().optional(),
  _abstract: z.string().optional(),
});

export type Person = z.infer<typeof PersonSchema>;

export const PersonCountSchema = z.object({
  wikidataId: z.string().optional(),
  name: z.string().optional(),
  count: z.number().optional(),
});

export type PersonCount = z.infer<typeof PersonCountSchema>;

export const PersonHolderSchema = z.object({
  wikidataId: z.string().optional(),
  name: z.string().optional(),
});

export type PersonHolder = z.infer<typeof PersonHolderSchema>;

export const PlaceSchema = z.object({
  osmId: z.string().optional(),
  road: z.string().optional(),
  quarter: z.string().optional(),
  suburb: z.string().optional(),
  city: z.string().optional(),
  town: z.string().optional(),
  county: z.string().optional(),
  stateDistrict: z.string().optional(),
  state: z.string().optional(),
  postcode: z.string().optional(),
  country: z.string().optional(),
  countryCode: z.string().optional(),
  amenity: z.string().optional(),
  neighbourhood: z.string().optional(),
  coordinates: z.unknown().optional(),
});

export type Place = z.infer<typeof PlaceSchema>;

export const QuerySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  articles: z.array(z.unknown()).default([]),
});

export type QuerySearchResult = z.infer<typeof QuerySearchResultSchema>;

export const QuestionSchema = z.object({
  question: z.string().optional(),
  answer: z.string().optional(),
  references: z.array(z.string()).default([]),
});

export type Question = z.infer<typeof QuestionSchema>;

export const RecordStatHolderSchema = z.object({
  name: z.string().optional(),
  count: z.number().optional(),
});

export type RecordStatHolder = z.infer<typeof RecordStatHolderSchema>;

export const ScoredDataArticleSchema = z.object({
  score: z.number().optional(),
  data: z.unknown().optional(),
});

export type ScoredDataArticle = z.infer<typeof ScoredDataArticleSchema>;

export const ScoredDataWikiDataSchema = z.object({
  score: z.number().optional(),
  data: z.unknown().optional(),
});

export type ScoredDataWikiData = z.infer<typeof ScoredDataWikiDataSchema>;

export const SentimentHolderSchema = z.object({
  positive: z.number().optional(),
  negative: z.number().optional(),
  neutral: z.number().optional(),
});

export type SentimentHolder = z.infer<typeof SentimentHolderSchema>;

export const SortBySchema = z.enum([
  "createdAt",
  "updatedAt",
  "relevance",
  "count",
  "totalCount",
]);

export type SortBy = z.infer<typeof SortBySchema>;

export const SortBy = {
  CreatedAt: "createdAt",
  UpdatedAt: "updatedAt",
  Relevance: "relevance",
  Count: "count",
  TotalCount: "totalCount",
} as const;

export const SourceSchema = z.object({
  id: z.string().optional(),
  domain: z.string().optional(),
  name: z.string().optional(),
  primaryRecordId: z.string().optional(),
  updatedAt: z.string().optional(),
  altNames: z.array(z.string()).default([]),
  description: z.string().optional(),
  avgMonthlyPosts: z.number().optional(),
  paywall: z.boolean().optional(),
  location: z.unknown().optional(),
  topCategories: z.array(z.unknown()).default([]),
  topTopics: z.array(z.unknown()).default([]),
  topCountries: z.array(z.unknown()).default([]),
  topLabels: z.array(z.unknown()).default([]),
  avgBiasRating: z.string().optional(),
  adFontesBiasRating: z.string().optional(),
  allSidesBiasRating: z.string().optional(),
  mbfcBiasRating: z.string().optional(),
  monthlyVisits: z.number().optional(),
  globalRank: z.number().optional(),
  logoLarge: z.unknown().optional(),
  logoFavIcon: z.unknown().optional(),
  logoSquare: z.unknown().optional(),
});

export type Source = z.infer<typeof SourceSchema>;

export const SourceHolderSchema = z.object({
  domain: z.string().optional(),
  paywall: z.boolean().optional(),
  location: z.unknown().optional(),
});

export type SourceHolder = z.infer<typeof SourceHolderSchema>;

export const SourceLocationSchema = z.object({
  country: z.string().optional(),
  state: z.string().optional(),
  county: z.string().optional(),
  city: z.string().optional(),
  coordinates: z.unknown().optional(),
});

export type SourceLocation = z.infer<typeof SourceLocationSchema>;

/**
 * Source search result
 * @export
 */
export const SourceSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type SourceSearchResult = z.infer<typeof SourceSearchResultSchema>;

export const SourceTopStatHolderSchema = z.object({
  name: z.string().optional(),
  count: z.number().optional(),
});

export type SourceTopStatHolder = z.infer<typeof SourceTopStatHolderSchema>;

/**
 * Story search result
 * @export
 */
export const StorySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type StorySearchResult = z.infer<typeof StorySearchResultSchema>;

/**
 * Request body for the Search-Summarizer endpoint. Contains the userâ€™s summary instructions, how many articles to include, which fields to use, the retrieval method, and LLM generation settings.
 * @export
 */
export const SummaryBodySchema = z.object({
  /**
   * Instructions guiding how the summary should be written. Maximum length: 2 048 characters.
   */
  prompt: z.string().optional(),
  /**
   * The maximum number of articles to factor into the summary.
   */
  maxArticleCount: z.number().optional(),
  /**
   * The maximum number of articles that should be returned in the response. This can be used to return fewer than maxArticleCount results.
   */
  returnedArticleCount: z.number().optional(),
  /**
   * Which article fields to include when generating the summary. Up to three values from TITLE, CONTENT, SUMMARY.
   */
  summarizeFields: z.enum(["TITLE", "CONTENT", "SUMMARY"]).optional(),
  /**
   * Method for selecting articles: ARTICLES (include all matches) or CLUSTERS (one per cluster).
   */
  method: z.enum(["ARTICLES", "CLUSTERS"]).optional(),
  /**
   * The underlying LLM model to use for generation.
   */
  model: z
    .enum([
      "gpt-4o",
      "gpt-4o-mini",
      "gpt-4.1",
      "gpt-4.1-mini",
      "gpt-4.1-nano",
      "llama-3.3-70b-versatile",
      "deepseek-r1-distill-llama-70b",
    ])
    .optional(),
  /**
   * Sampling temperature for the LLM (0.0 = deterministic to 2.0 = very creative).
   */
  temperature: z.number().optional(),
  /**
   * Nucleus sampling (top-p) for the LLM (0.0 to 1.0).
   */
  topP: z.number().optional(),
  /**
   * Maximum number of tokens to generate in the summary.
   */
  maxTokens: z.number().optional(),
});

export type SummaryBody = z.infer<typeof SummaryBodySchema>;

/**
 * @export
 */
export const SummaryBodySummarizeFieldsEnum = {
  Title: "TITLE",
  Content: "CONTENT",
  Summary: "SUMMARY",
} as const;
export type SummaryBodySummarizeFieldsEnum =
  (typeof SummaryBodySummarizeFieldsEnum)[keyof typeof SummaryBodySummarizeFieldsEnum];

/**
 * @export
 */
export const SummaryBodyMethodEnum = {
  Articles: "ARTICLES",
  Clusters: "CLUSTERS",
} as const;
export type SummaryBodyMethodEnum =
  (typeof SummaryBodyMethodEnum)[keyof typeof SummaryBodyMethodEnum];

/**
 * @export
 */
export const SummaryBodyModelEnum = {
  Gpt4o: "gpt-4o",
  Gpt4oMini: "gpt-4o-mini",
  Gpt41: "gpt-4.1",
  Gpt41Mini: "gpt-4.1-mini",
  Gpt41Nano: "gpt-4.1-nano",
  Llama3370bVersatile: "llama-3.3-70b-versatile",
  DeepseekR1DistillLlama70b: "deepseek-r1-distill-llama-70b",
} as const;
export type SummaryBodyModelEnum =
  (typeof SummaryBodyModelEnum)[keyof typeof SummaryBodyModelEnum];

export const SummarySearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  summary: z.string(),
  results: z.array(z.unknown()).default([]),
});

export type SummarySearchResult = z.infer<typeof SummarySearchResultSchema>;

export const SymbolHolderSchema = z.object({
  symbol: z.string().optional(),
  exchange: z.string().optional(),
  exchangeShortName: z.string().optional(),
  ipoDate: z.string().optional(),
});

export type SymbolHolder = z.infer<typeof SymbolHolderSchema>;

export const TooManyRequestsExceptionSchema = z.object({
  cause: z.unknown().optional(),
  stackTrace: z.array(z.unknown()).default([]),
  status: z
    .enum([
      "100 CONTINUE",
      "101 SWITCHING_PROTOCOLS",
      "102 PROCESSING",
      "103 CHECKPOINT",
      "200 OK",
      "201 CREATED",
      "202 ACCEPTED",
      "203 NON_AUTHORITATIVE_INFORMATION",
      "204 NO_CONTENT",
      "205 RESET_CONTENT",
      "206 PARTIAL_CONTENT",
      "207 MULTI_STATUS",
      "208 ALREADY_REPORTED",
      "226 IM_USED",
      "300 MULTIPLE_CHOICES",
      "301 MOVED_PERMANENTLY",
      "302 FOUND",
      "302 MOVED_TEMPORARILY",
      "303 SEE_OTHER",
      "304 NOT_MODIFIED",
      "305 USE_PROXY",
      "307 TEMPORARY_REDIRECT",
      "308 PERMANENT_REDIRECT",
      "400 BAD_REQUEST",
      "401 UNAUTHORIZED",
      "402 PAYMENT_REQUIRED",
      "403 FORBIDDEN",
      "404 NOT_FOUND",
      "405 METHOD_NOT_ALLOWED",
      "406 NOT_ACCEPTABLE",
      "407 PROXY_AUTHENTICATION_REQUIRED",
      "408 REQUEST_TIMEOUT",
      "409 CONFLICT",
      "410 GONE",
      "411 LENGTH_REQUIRED",
      "412 PRECONDITION_FAILED",
      "413 PAYLOAD_TOO_LARGE",
      "413 REQUEST_ENTITY_TOO_LARGE",
      "414 URI_TOO_LONG",
      "414 REQUEST_URI_TOO_LONG",
      "415 UNSUPPORTED_MEDIA_TYPE",
      "416 REQUESTED_RANGE_NOT_SATISFIABLE",
      "417 EXPECTATION_FAILED",
      "418 I_AM_A_TEAPOT",
      "419 INSUFFICIENT_SPACE_ON_RESOURCE",
      "420 METHOD_FAILURE",
      "421 DESTINATION_LOCKED",
      "422 UNPROCESSABLE_ENTITY",
      "423 LOCKED",
      "424 FAILED_DEPENDENCY",
      "425 TOO_EARLY",
      "426 UPGRADE_REQUIRED",
      "428 PRECONDITION_REQUIRED",
      "429 TOO_MANY_REQUESTS",
      "431 REQUEST_HEADER_FIELDS_TOO_LARGE",
      "451 UNAVAILABLE_FOR_LEGAL_REASONS",
      "500 INTERNAL_SERVER_ERROR",
      "501 NOT_IMPLEMENTED",
      "502 BAD_GATEWAY",
      "503 SERVICE_UNAVAILABLE",
      "504 GATEWAY_TIMEOUT",
      "505 HTTP_VERSION_NOT_SUPPORTED",
      "506 VARIANT_ALSO_NEGOTIATES",
      "507 INSUFFICIENT_STORAGE",
      "508 LOOP_DETECTED",
      "509 BANDWIDTH_LIMIT_EXCEEDED",
      "510 NOT_EXTENDED",
      "511 NETWORK_AUTHENTICATION_REQUIRED",
    ])
    .optional(),
  message: z.string().optional(),
  suppressed: z.array(z.unknown()).default([]),
  localizedMessage: z.string().optional(),
});

export type TooManyRequestsException = z.infer<
  typeof TooManyRequestsExceptionSchema
>;

/**
 * @export
 */
export const TooManyRequestsExceptionStatusEnum = {
  _100Continue: "100 CONTINUE",
  _101SwitchingProtocols: "101 SWITCHING_PROTOCOLS",
  _102Processing: "102 PROCESSING",
  _103Checkpoint: "103 CHECKPOINT",
  _200Ok: "200 OK",
  _201Created: "201 CREATED",
  _202Accepted: "202 ACCEPTED",
  _203NonAuthoritativeInformation: "203 NON_AUTHORITATIVE_INFORMATION",
  _204NoContent: "204 NO_CONTENT",
  _205ResetContent: "205 RESET_CONTENT",
  _206PartialContent: "206 PARTIAL_CONTENT",
  _207MultiStatus: "207 MULTI_STATUS",
  _208AlreadyReported: "208 ALREADY_REPORTED",
  _226ImUsed: "226 IM_USED",
  _300MultipleChoices: "300 MULTIPLE_CHOICES",
  _301MovedPermanently: "301 MOVED_PERMANENTLY",
  _302Found: "302 FOUND",
  _302MovedTemporarily: "302 MOVED_TEMPORARILY",
  _303SeeOther: "303 SEE_OTHER",
  _304NotModified: "304 NOT_MODIFIED",
  _305UseProxy: "305 USE_PROXY",
  _307TemporaryRedirect: "307 TEMPORARY_REDIRECT",
  _308PermanentRedirect: "308 PERMANENT_REDIRECT",
  _400BadRequest: "400 BAD_REQUEST",
  _401Unauthorized: "401 UNAUTHORIZED",
  _402PaymentRequired: "402 PAYMENT_REQUIRED",
  _403Forbidden: "403 FORBIDDEN",
  _404NotFound: "404 NOT_FOUND",
  _405MethodNotAllowed: "405 METHOD_NOT_ALLOWED",
  _406NotAcceptable: "406 NOT_ACCEPTABLE",
  _407ProxyAuthenticationRequired: "407 PROXY_AUTHENTICATION_REQUIRED",
  _408RequestTimeout: "408 REQUEST_TIMEOUT",
  _409Conflict: "409 CONFLICT",
  _410Gone: "410 GONE",
  _411LengthRequired: "411 LENGTH_REQUIRED",
  _412PreconditionFailed: "412 PRECONDITION_FAILED",
  _413PayloadTooLarge: "413 PAYLOAD_TOO_LARGE",
  _413RequestEntityTooLarge: "413 REQUEST_ENTITY_TOO_LARGE",
  _414UriTooLong: "414 URI_TOO_LONG",
  _414RequestUriTooLong: "414 REQUEST_URI_TOO_LONG",
  _415UnsupportedMediaType: "415 UNSUPPORTED_MEDIA_TYPE",
  _416RequestedRangeNotSatisfiable: "416 REQUESTED_RANGE_NOT_SATISFIABLE",
  _417ExpectationFailed: "417 EXPECTATION_FAILED",
  _418IAmATeapot: "418 I_AM_A_TEAPOT",
  _419InsufficientSpaceOnResource: "419 INSUFFICIENT_SPACE_ON_RESOURCE",
  _420MethodFailure: "420 METHOD_FAILURE",
  _421DestinationLocked: "421 DESTINATION_LOCKED",
  _422UnprocessableEntity: "422 UNPROCESSABLE_ENTITY",
  _423Locked: "423 LOCKED",
  _424FailedDependency: "424 FAILED_DEPENDENCY",
  _425TooEarly: "425 TOO_EARLY",
  _426UpgradeRequired: "426 UPGRADE_REQUIRED",
  _428PreconditionRequired: "428 PRECONDITION_REQUIRED",
  _429TooManyRequests: "429 TOO_MANY_REQUESTS",
  _431RequestHeaderFieldsTooLarge: "431 REQUEST_HEADER_FIELDS_TOO_LARGE",
  _451UnavailableForLegalReasons: "451 UNAVAILABLE_FOR_LEGAL_REASONS",
  _500InternalServerError: "500 INTERNAL_SERVER_ERROR",
  _501NotImplemented: "501 NOT_IMPLEMENTED",
  _502BadGateway: "502 BAD_GATEWAY",
  _503ServiceUnavailable: "503 SERVICE_UNAVAILABLE",
  _504GatewayTimeout: "504 GATEWAY_TIMEOUT",
  _505HttpVersionNotSupported: "505 HTTP_VERSION_NOT_SUPPORTED",
  _506VariantAlsoNegotiates: "506 VARIANT_ALSO_NEGOTIATES",
  _507InsufficientStorage: "507 INSUFFICIENT_STORAGE",
  _508LoopDetected: "508 LOOP_DETECTED",
  _509BandwidthLimitExceeded: "509 BANDWIDTH_LIMIT_EXCEEDED",
  _510NotExtended: "510 NOT_EXTENDED",
  _511NetworkAuthenticationRequired: "511 NETWORK_AUTHENTICATION_REQUIRED",
} as const;
export type TooManyRequestsExceptionStatusEnum =
  (typeof TooManyRequestsExceptionStatusEnum)[keyof typeof TooManyRequestsExceptionStatusEnum];

export const TopicDtoSchema = z.object({
  id: z.number().optional(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
  name: z.string().optional(),
  labels: z.unknown().optional(),
});

export type TopicDto = z.infer<typeof TopicDtoSchema>;

export const TopicHolderSchema = z.object({
  name: z.string().optional(),
});

export type TopicHolder = z.infer<typeof TopicHolderSchema>;

export const TopicLabelsSchema = z.object({
  category: z.string().optional(),
  subcategory: z.string().optional(),
});

export type TopicLabels = z.infer<typeof TopicLabelsSchema>;

/**
 * Topic search result
 * @export
 */
export const TopicSearchResultSchema = z.object({
  total: z.number(),
  data: z.array(z.unknown()).default([]),
});

export type TopicSearchResult = z.infer<typeof TopicSearchResultSchema>;

export const WebResourcesSchema = z.object({
  careers: z.string().optional(),
  about: z.string().optional(),
  blog: z.string().optional(),
  events: z.string().optional(),
  sitemap: z.string().optional(),
  updates: z.string().optional(),
  linkedin: z.string().optional(),
  facebook: z.string().optional(),
  instagram: z.string().optional(),
  medium: z.string().optional(),
  reddit: z.string().optional(),
  threads: z.string().optional(),
  tiktok: z.string().optional(),
  x: z.string().optional(),
  wellfound: z.string().optional(),
  youtube: z.string().optional(),
  wikipedia: z.string().optional(),
});

export type WebResources = z.infer<typeof WebResourcesSchema>;

export const WikiDataSchema = z.object({
  pageId: z.string().optional(),
  sectionId: z.string().optional(),
  wikiPageId: z.number().optional(),
  wikiRevisionId: z.number().optional(),
  wikiRevisionTs: z.string().optional(),
  wikiCode: z.string().optional(),
  wikiNamespace: z.number().optional(),
  wikiTitle: z.string().optional(),
  wikidataId: z.string().optional(),
  wikidataInstanceOf: z.array(z.unknown()).default([]),
  redirectTitles: z.array(z.string()).default([]),
  pageviews: z.number().optional(),
  title: z.string().optional(),
  styleLevel: z.number().optional(),
  content: z.string().optional(),
});

export type WikiData = z.infer<typeof WikiDataSchema>;

export const WikiPageSchema = z.object({
  id: z.string().optional(),
  scrapedAt: z.string().optional(),
  wikiPageId: z.number().optional(),
  wikiRevisionId: z.number().optional(),
  wikiRevisionTs: z.string().optional(),
  wikiCode: z.string().optional(),
  wikiNamespace: z.number().optional(),
  wikiTitle: z.string().optional(),
  url: z.string().optional(),
  topImage: z.string().optional(),
  wikidataId: z.string().optional(),
  wikidataInstanceOf: z.array(z.unknown()).default([]),
  redirectTitles: z.array(z.string()).default([]),
  summary: z.string().optional(),
  sections: z.array(z.unknown()).default([]),
  categories: z.array(z.string()).default([]),
  externalLinks: z.array(z.string()).default([]),
  references: z.array(z.string()).default([]),
  pageviews: z.number().optional(),
});

export type WikiPage = z.infer<typeof WikiPageSchema>;

export const WikiPageSectionHolderSchema = z.object({
  id: z.string().optional(),
  title: z.string().optional(),
  styleLevel: z.number().optional(),
  loc: z.array(z.number()).default([]),
  textRaw: z.string().optional(),
  textRich: z.string().optional(),
});

export type WikiPageSectionHolder = z.infer<typeof WikiPageSectionHolderSchema>;

export const WikidataDateHolderSchema = z.object({
  time: z.string().optional(),
  precision: z.string().optional(),
});

export type WikidataDateHolder = z.infer<typeof WikidataDateHolderSchema>;

export const WikidataLabelHolderSchema = z.object({
  wikidataId: z.string().optional(),
  label: z.string().optional(),
});

export type WikidataLabelHolder = z.infer<typeof WikidataLabelHolderSchema>;

export const WikidataPoliticalPartyHolderSchema = z.object({
  wikidataId: z.string().optional(),
  label: z.string().optional(),
  startTime: z.unknown().optional(),
  endTime: z.unknown().optional(),
});

export type WikidataPoliticalPartyHolder = z.infer<
  typeof WikidataPoliticalPartyHolderSchema
>;

export const WikidataPositionHolderSchema = z.object({
  wikidataId: z.string().optional(),
  label: z.string().optional(),
  startTime: z.unknown().optional(),
  endTime: z.unknown().optional(),
  employer: z.unknown().optional(),
});

export type WikidataPositionHolder = z.infer<
  typeof WikidataPositionHolderSchema
>;

/**
 * Complex filter structure for Wikipedia page searches that supports nested logical operations (AND, OR, NOT) and multiple filtering criteria.
 * @export
 */
export const WikipediaSearchFilterSchema = z.object({
  /**
   * Filter by specific Perigon page identifiers. Accepts either a single ID or an array of IDs. Returns only pages matching these IDs.
   */
  pageId: z.array(z.string()).default([]),
  /**
   * Filter by specific section identifiers. Accepts either a single ID or an array of IDs. Returns only pages containing these sections.
   */
  sectionId: z.array(z.string()).default([]),
  /**
   * Filter by specific Wikipedia page identifiers. Accepts either a single ID or an array of IDs. Returns only pages matching these IDs.
   */
  wikiPageId: z.array(z.number()).default([]),
  /**
   * Filter by specific Perigon page revision identifiers. Accepts either a single ID or an array of IDs. Returns only pages matching these IDs.
   */
  wikiRevisionId: z.array(z.number()).default([]),
  /**
   * Filter by specific Wikipedia project codes. Returns only pages matching these projects.
   */
  wikiCode: z.array(z.string()).default([]),
  /**
   * Filter by specific Wikipedia namespaces. Returns only pages matching these namespaces.
   */
  wikiNamespace: z.array(z.number()).default([]),
  /**
   * Filter by specific Wikidata entity IDs. Returns only pages whose Wikidata entities match those ids.
   */
  wikidataId: z.array(z.string()).default([]),
  /**
   * Filter by specific Wikidata entity IDs. Returns only pages whose Wikidata entities are instances of provided ids.
   */
  wikidataInstanceOfId: z.array(z.string()).default([]),
  /**
   * Filter by specific Wikidata entity labels. Returns only pages whose Wikidata entities are instances of these labels.
   */
  wikidataInstanceOfLabel: z.array(z.string()).default([]),
  /**
   * Adds additional AND filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the AND logical operator.
   */
  aND: z.array(z.unknown()).default([]),
  /**
   * Adds additional OR filter objects. These objects must be of the same type as the original filter object and will be combined with the existing filter using the OR logical operator.
   */
  oR: z.array(z.unknown()).default([]),
  /**
   * A filter object for logical NOT operations
   */
  nOT: z.array(z.unknown()).default([]),
});

export type WikipediaSearchFilter = z.infer<typeof WikipediaSearchFilterSchema>;

export const WikipediaSearchParamsSchema = z.object({
  /**
   * Natural language query to search the Wikipedia pages database
   */
  prompt: z.string(),
  filter: z.unknown().optional(),
  /**
   * 'wikiRevisionFrom' filter, will search pages modified after the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00.
   */
  wikiRevisionFrom: z.string().optional(),
  /**
   * 'wikiRevisionFrom' filter, will search pages modified before the specified date, the date could be passed as ISO or 'yyyy-mm-dd'. Date time in ISO format, ie. 2024-01-01T00:00:00.
   */
  wikiRevisionTo: z.string().optional(),
  /**
   * 'pageviewsFrom' filter, will search pages with at least the provided number of views per day.
   */
  pageviewsFrom: z.number().optional(),
  /**
   * 'pageviewsFrom' filter, will search pages with at most the provided number of views per day.
   */
  pageviewsTo: z.number().optional(),
  /**
   * The number of items per page.
   */
  size: z.number().optional(),
  /**
   * The page number to retrieve.
   */
  page: z.number().optional(),
});

export type WikipediaSearchParams = z.infer<typeof WikipediaSearchParamsSchema>;

/**
 * Wikipedia search result
 * @export
 */
export const WikipediaSearchResultSchema = z.object({
  status: z.number(),
  numResults: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type WikipediaSearchResult = z.infer<typeof WikipediaSearchResultSchema>;

/**
 * Wikipedia vector search result
 * @export
 */
export const WikipediaVectorSearchResultSchema = z.object({
  status: z.number(),
  results: z.array(z.unknown()).default([]),
});

export type WikipediaVectorSearchResult = z.infer<
  typeof WikipediaVectorSearchResultSchema
>;
