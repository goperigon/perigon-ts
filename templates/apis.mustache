{{>licenseInfo}}

import * as runtime from '../runtime{{importFileExtension}}';
import { z } from 'zod';
{{#imports.0}}
import type {
  {{#imports}}
  {{className}},
  {{/imports}}
} from '../models/index{{importFileExtension}}';
import {
    {{#imports}}
    {{className}}Schema,
    {{/imports}}
} from '../models/index{{importFileExtension}}';
{{/imports.0}}

{{#operations}}
{{#operation}}
{{#allParams.0}}

{{#queryParams.0}}
export const {{operationIdCamelCase}}QuerySchema = z.object({
{{#queryParams}}
    {{>param}},
{{/queryParams}}
});
{{/queryParams.0}}

{{#bodyParam}}
export const {{operationIdCamelCase}}BodySchema = z.object({
    {{>param}},
});
{{/bodyParam}}

{{#pathParams.0}}
export const {{operationIdCamelCase}}PathSchema = z.object({
{{#pathParams}}
    {{>param}},
{{/pathParams}}
});
{{/pathParams.0}}

{{#headerParams.0}}
export const {{operationIdCamelCase}}HeaderSchema = z.object({
{{#headerParams}}
    {{>param}},
{{/headerParams}}
});
{{/headerParams.0}}

export const {{operationIdCamelCase}}RequestSchema = z.object({
{{#queryParams.0}}...{{operationIdCamelCase}}QuerySchema.shape,{{/queryParams.0}}
{{#bodyParam}}...{{operationIdCamelCase}}BodySchema.shape,{{/bodyParam}}
{{#pathParams.0}}...{{operationIdCamelCase}}PathSchema.shape,{{/pathParams.0}}
{{#headerParams.0}}...{{operationIdCamelCase}}HeaderSchema.shape,{{/headerParams.0}}
});

export type {{operationIdCamelCase}}Request = z.input<typeof {{operationIdCamelCase}}RequestSchema>;

{{/allParams.0}}
{{/operation}}
{{/operations}}
{{#operations}}
/**
 * {{#lambda.indented_star_1}}{{{unescapedDescription}}}{{/lambda.indented_star_1}}
 */
export class {{classname}} extends runtime.BaseAPI {

    {{#operation}}
    /**
     {{#notes}}
     * {{&notes}}
     {{/notes}}
     {{#summary}}
     * {{&summary}}
     {{/summary}}
     {{#isDeprecated}}
     * @deprecated
     {{/isDeprecated}}
     */
    async {{nickname}}({{#allParams.0}}requestParameters: {{operationIdCamelCase}}Request{{^hasRequiredParams}} = {}{{/hasRequiredParams}}, {{/allParams.0}}initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{{{returnType}}}{{#returnType}}{{#isResponseOptional}} | null | undefined {{/isResponseOptional}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
        {{#allParams.0}}
        const params = {{operationIdCamelCase}}RequestSchema.parse(requestParameters);
        {{#queryParams.0}}
        const queryParameters = {{operationIdCamelCase}}QuerySchema.parse(params);
        {{/queryParams.0}}
        {{/allParams.0}}

        const headerParameters: runtime.HTTPHeaders = {};
        {{#bodyParam}}
        {{^consumes}}
        headerParameters['Content-Type'] = 'application/json';
        {{/consumes}}
        {{#consumes.0}}
        headerParameters['Content-Type'] = '{{{mediaType}}}';
        {{/consumes.0}}
        {{/bodyParam}}
        {{#headerParams}}
        {{#isArray}}
        if (params.{{paramName}} !== undefined) {
            headerParameters['{{baseName}}'] = {{#uniqueItems}}Array.from({{/uniqueItems}}params.{{paramName}}{{#uniqueItems}}){{/uniqueItems}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
        }
        {{/isArray}}
        {{^isArray}}
        if (params.{{paramName}} !== undefined) {
            headerParameters['{{baseName}}'] = String(params.{{paramName}});
        }
        {{/isArray}}
        {{/headerParams}}

        {{#authMethods}}
        {{#isBasic}}
        {{#isBasicBearer}}
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        {{/isBasicBearer}}
        {{/isBasic}}
        {{/authMethods}}

        const response = await this.request({
            path: `{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String(params.{{paramName}}))){{/pathParams}},
            method: '{{httpMethod}}',
            headers: headerParameters,
            {{#queryParams.0}}query: queryParameters,{{/queryParams.0}}
            {{#hasBodyParam}}
            {{#bodyParam}}
            {{#isContainer}}
            {{^withoutRuntimeChecks}}
            body: params.{{paramName}}{{#isArray}}{{/isArray}},
            {{/withoutRuntimeChecks}}
            {{#withoutRuntimeChecks}}
            body: params.{{paramName}},
            {{/withoutRuntimeChecks}}
            {{/isContainer}}
            {{^isContainer}}
            {{^isPrimitiveType}}
             body: params.{{paramName}},            {{/isPrimitiveType}}
            {{#isPrimitiveType}}
            body: params.{{paramName}} as any,
            {{/isPrimitiveType}}
            {{/isContainer}}
            {{/bodyParam}}
            {{/hasBodyParam}}
        }, initOverrides);

        {{#returnType}}
        const raw = await response.json()
        return {{returnBaseType}}Schema.parse(raw);
        {{/returnType}}
        {{^returnType}}
        // void return type
        {{/returnType}}
    }
    {{/operation}}
}
{{/operations}}
{{#hasEnums}}

{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
{{#stringEnums}}
/**
  * @export
  * @enum {string}
  */
export enum {{operationIdCamelCase}}{{enumName}} {
{{#allowableValues}}
    {{#enumVars}}
    {{name}} = {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
}
{{/stringEnums}}
{{^stringEnums}}
/**
 * @export
 */
export const {{operationIdCamelCase}}{{enumName}} = {
{{#allowableValues}}
    {{#enumVars}}
    {{name}}: {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
} as const;
export type {{operationIdCamelCase}}{{enumName}} = typeof {{operationIdCamelCase}}{{enumName}}[keyof typeof {{operationIdCamelCase}}{{enumName}}];
{{/stringEnums}}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
{{/hasEnums}}
