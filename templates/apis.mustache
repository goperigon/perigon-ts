{{>licenseInfo}}

import * as runtime from '../runtime{{importFileExtension}}';
import { z } from 'zod';
{{#imports.0}}
import type {
  {{#imports}}
  {{className}},
  {{/imports}}
} from '../models/index{{importFileExtension}}';
import {
    {{#imports}}
    {{className}}Schema,
    {{/imports}}
} from '../models/index{{importFileExtension}}';
{{/imports.0}}

{{#operations}}
{{#operation}}
{{#allParams.0}}
{{#queryParams.0}}
export const {{operationIdCamelCase}}QuerySchema = z.object({
{{#queryParams}}
    /**
     * {{#description}}{{description}}{{/description}}{{^description}}Parameter {{paramName}}{{/description}}
     {{#isEnum}}
     * @type {{{datatypeWithEnum}}}
     {{#allowableValues}}
     * @values {{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}
     {{/allowableValues}}
     {{/isEnum}}
     {{#required}}
     * @required
     {{/required}}
     */
    {{paramName}}: {{#isEnum}}z.enum([{{#allowableValues}}{{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]){{/isEnum}}{{^isEnum}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{^isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isDateType}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isArray}}z.array({{#items}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isDateTimeType}}{{^isDateType}}z.any(){{/isDateType}}{{/isDateTimeType}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/items}}){{/isArray}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isArray}}z.any(){{/isArray}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/isDateType}}{{/isDateTimeType}}{{/isEnum}}{{^required}}.optional(){{/required}}{{#isNullable}}.nullable(){{/isNullable}},
{{/queryParams}}
});

{{/queryParams.0}}
{{#bodyParam}}
export const {{operationIdCamelCase}}BodySchema = z.object({
    /**
     * {{#description}}{{description}}{{/description}}{{^description}}Parameter {{paramName}}{{/description}}
     {{#isEnum}}
     * @type {{{datatypeWithEnum}}}
     {{#allowableValues}}
     * @values {{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}
     {{/allowableValues}}
     {{/isEnum}}
     {{#required}}
     * @required
     {{/required}}
     */
    {{paramName}}: {{#isEnum}}z.enum([{{#allowableValues}}{{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]){{/isEnum}}{{^isEnum}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{^isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isDateType}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isArray}}z.array({{#items}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isDateTimeType}}{{^isDateType}}z.any(){{/isDateType}}{{/isDateTimeType}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/items}}){{/isArray}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isArray}}z.any(){{/isArray}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/isDateType}}{{/isDateTimeType}}{{/isEnum}}{{^required}}.optional(){{/required}}{{#isNullable}}.nullable(){{/isNullable}},
});

{{/bodyParam}}
{{#pathParams.0}}
export const {{operationIdCamelCase}}PathSchema = z.object({
{{#pathParams}}
    /**
     * {{#description}}{{description}}{{/description}}{{^description}}Parameter {{paramName}}{{/description}}
     {{#isEnum}}
     * @type {{{datatypeWithEnum}}}
     {{#allowableValues}}
     * @values {{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}
     {{/allowableValues}}
     {{/isEnum}}
     {{#required}}
     * @required
     {{/required}}
     */
    {{paramName}}: {{#isEnum}}z.enum([{{#allowableValues}}{{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]){{/isEnum}}{{^isEnum}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{^isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isDateType}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isArray}}z.array({{#items}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isDateTimeType}}{{^isDateType}}z.any(){{/isDateType}}{{/isDateTimeType}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/items}}){{/isArray}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isArray}}z.any(){{/isArray}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/isDateType}}{{/isDateTimeType}}{{/isEnum}}{{^required}}.optional(){{/required}}{{#isNullable}}.nullable(){{/isNullable}},
{{/pathParams}}
});

{{/pathParams.0}}
{{#headerParams.0}}
export const {{operationIdCamelCase}}HeaderSchema = z.object({
{{#headerParams}}
    /**
     * {{#description}}{{description}}{{/description}}{{^description}}Parameter {{paramName}}{{/description}}
     {{#isEnum}}
     * @type {{{datatypeWithEnum}}}
     {{#allowableValues}}
     * @values {{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}
     {{/allowableValues}}
     {{/isEnum}}
     {{#required}}
     * @required
     {{/required}}
     */
    {{paramName}}: {{#isEnum}}z.enum([{{#allowableValues}}{{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]){{/isEnum}}{{^isEnum}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{^isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isDateType}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isArray}}z.array({{#items}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isDateTimeType}}{{^isDateType}}z.any(){{/isDateType}}{{/isDateTimeType}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/items}}){{/isArray}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isArray}}z.any(){{/isArray}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/isDateType}}{{/isDateTimeType}}{{/isEnum}}{{^required}}.optional(){{/required}}{{#isNullable}}.nullable(){{/isNullable}},
{{/headerParams}}
});

{{/headerParams.0}}
{{#formParams.0}}
export const {{operationIdCamelCase}}FormSchema = z.object({
{{#formParams}}
    /**
     * {{#description}}{{description}}{{/description}}{{^description}}Parameter {{paramName}}{{/description}}
     {{#isEnum}}
     * @type {{{datatypeWithEnum}}}
     {{#allowableValues}}
     * @values {{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}
     {{/allowableValues}}
     {{/isEnum}}
     {{#required}}
     * @required
     {{/required}}
     */
    {{paramName}}: {{#isEnum}}z.enum([{{#allowableValues}}{{#enumVars}}'{{{value}}}'{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]){{/isEnum}}{{^isEnum}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{^isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isDateType}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isArray}}z.array({{#items}}{{#isString}}z.string(){{/isString}}{{#isNumeric}}z.number(){{/isNumeric}}{{#isBoolean}}z.boolean(){{/isBoolean}}{{#isDateTimeType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString() : val){{/isDateTimeType}}{{#isDateType}}z.union([z.date(), z.string()]).transform(val => val instanceof Date ? val.toISOString().substring(0,10) : val){{/isDateType}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isDateTimeType}}{{^isDateType}}z.any(){{/isDateType}}{{/isDateTimeType}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/items}}){{/isArray}}{{^isString}}{{^isNumeric}}{{^isBoolean}}{{^isArray}}z.any(){{/isArray}}{{/isBoolean}}{{/isNumeric}}{{/isString}}{{/isDateType}}{{/isDateTimeType}}{{/isEnum}}{{^required}}.optional(){{/required}}{{#isNullable}}.nullable(){{/isNullable}},
{{/formParams}}
});

{{/formParams.0}}
export const {{operationIdCamelCase}}RequestSchema = z.object({
{{#queryParams.0}}...{{operationIdCamelCase}}QuerySchema.shape,{{/queryParams.0}}
{{#bodyParam}}...{{operationIdCamelCase}}BodySchema.shape,{{/bodyParam}}
{{#pathParams.0}}...{{operationIdCamelCase}}PathSchema.shape,{{/pathParams.0}}
{{#headerParams.0}}...{{operationIdCamelCase}}HeaderSchema.shape,{{/headerParams.0}}
{{#formParams.0}}...{{operationIdCamelCase}}FormSchema.shape{{/formParams.0}}
});

export type {{operationIdCamelCase}}Request = z.input<typeof {{operationIdCamelCase}}RequestSchema>;

{{/allParams.0}}
{{/operation}}
{{/operations}}
{{#operations}}
/**
 * {{#lambda.indented_star_1}}{{{unescapedDescription}}}{{/lambda.indented_star_1}}
 */
export class {{classname}} extends runtime.BaseAPI {

    {{#operation}}
    /**
     {{#notes}}
     * {{&notes}}
     {{/notes}}
     {{#summary}}
     * {{&summary}}
     {{/summary}}
     {{#isDeprecated}}
     * @deprecated
     {{/isDeprecated}}
     */
    {{^useSingleRequestParameter}}
    async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}, {{/allParams}}initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{{{returnType}}}{{#returnType}}{{#isResponseOptional}} | null | undefined {{/isResponseOptional}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
        {{#allParams.0}}
        const params = {{operationIdCamelCase}}RequestSchema.parse({ {{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}} });
        {{#queryParams.0}}
        const queryParameters = {{operationIdCamelCase}}QuerySchema.parse(params);
        {{/queryParams.0}}
        {{/allParams.0}}

        const headerParameters: runtime.HTTPHeaders = {};
        {{#bodyParam}}
        {{^consumes}}
        headerParameters['Content-Type'] = 'application/json';
        {{/consumes}}
        {{#consumes.0}}
        headerParameters['Content-Type'] = '{{{mediaType}}}';
        {{/consumes.0}}
        {{/bodyParam}}
        {{#headerParams}}
        {{#isArray}}
        if (params.{{paramName}} !== undefined) {
            headerParameters['{{baseName}}'] = {{#uniqueItems}}Array.from({{/uniqueItems}}params.{{paramName}}{{#uniqueItems}}){{/uniqueItems}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
        }
        {{/isArray}}
        {{^isArray}}
        if (params.{{paramName}} !== undefined) {
            headerParameters['{{baseName}}'] = String(params.{{paramName}});
        }
        {{/isArray}}
        {{/headerParams}}

        {{#authMethods}}
        {{#isBasic}}
        {{#isBasicBasic}}
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        {{/isBasicBasic}}
        {{#isBasicBearer}}
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        {{/isBasicBearer}}
        {{/isBasic}}
        {{#isApiKey}}
        {{#isKeyInHeader}}
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["{{keyParamName}}"] = await this.configuration.apiKey("{{keyParamName}}");
        }
        {{/isKeyInHeader}}
        {{#isKeyInQuery}}
        if (this.configuration && this.configuration.apiKey) {
            queryParameters["{{keyParamName}}"] = await this.configuration.apiKey("{{keyParamName}}");
        }
        {{/isKeyInQuery}}
        {{/isApiKey}}
        {{#isOAuth}}
        if (this.configuration && this.configuration.accessToken) {
            headerParameters["Authorization"] = await this.configuration.accessToken("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
        }
        {{/isOAuth}}
        {{/authMethods}}

        {{#hasFormParams}}
        const consumes: runtime.Consume[] = [
            {{#consumes}}
            { contentType: '{{{mediaType}}}' },
            {{/consumes}}
        ];
        const canConsumeForm = runtime.canConsumeForm(consumes);
        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        {{#formParams}}
        {{#isFile}}
        useForm = canConsumeForm;
        {{/isFile}}
        {{/formParams}}
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        {{#formParams}}
        {{#isArray}}
        if (params.{{paramName}} !== undefined) {
            {{#isCollectionFormatMulti}}
            params.{{paramName}}.forEach((element) => {
                formParams.append('{{baseName}}{{#useSquareBracketsInArrayNames}}[]{{/useSquareBracketsInArrayNames}}', element as any);
            })
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
            formParams.append('{{baseName}}{{#useSquareBracketsInArrayNames}}[]{{/useSquareBracketsInArrayNames}}', {{#uniqueItems}}Array.from({{/uniqueItems}}params.{{paramName}}{{#uniqueItems}}){{/uniqueItems}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]));
            {{/isCollectionFormatMulti}}
        }
        {{/isArray}}
        {{^isArray}}
        if (params.{{paramName}} !== undefined) {
            {{#isDateTimeType}}
            formParams.append('{{baseName}}', (params.{{paramName}} as any).toISOString());
            {{/isDateTimeType}}
            {{^isDateTimeType}}
            {{#isPrimitiveType}}
            formParams.append('{{baseName}}', params.{{paramName}} as any);
            {{/isPrimitiveType}}
            {{^isPrimitiveType}}
            {{#isEnumRef}}
            formParams.append('{{baseName}}', params.{{paramName}} as any);
            {{/isEnumRef}}
            {{^isEnumRef}}
            {{^withoutRuntimeChecks}}
            formParams.append('{{baseName}}', new Blob([JSON.stringify(params.{{paramName}})], { type: "application/json", }));
            {{/withoutRuntimeChecks}}{{#withoutRuntimeChecks}}
            formParams.append('{{baseName}}', new Blob([JSON.stringify(params.{{paramName}})], { type: "application/json", }));
            {{/withoutRuntimeChecks}}
            {{/isEnumRef}}
            {{/isPrimitiveType}}
            {{/isDateTimeType}}
        }
        {{/isArray}}
        {{/formParams}}
        {{/hasFormParams}}

        const response = await this.request({
            path: `{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String(params.{{paramName}}))){{/pathParams}},
            method: '{{httpMethod}}',
            headers: headerParameters,
            {{#queryParams.0}}query: queryParameters,{{/queryParams.0}}
            {{#hasBodyParam}}
            {{#bodyParam}}
            {{#isContainer}}
            {{^withoutRuntimeChecks}}
            body: params.{{paramName}}{{#isArray}}{{/isArray}},
            {{/withoutRuntimeChecks}}
            {{#withoutRuntimeChecks}}
            body: params.{{paramName}},
            {{/withoutRuntimeChecks}}
            {{/isContainer}}
            {{^isContainer}}
            {{^isPrimitiveType}}
             body: params.{{paramName}},            {{/isPrimitiveType}}
            {{#isPrimitiveType}}
            body: params.{{paramName}} as any,
            {{/isPrimitiveType}}
            {{/isContainer}}
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{#hasFormParams}}
            body: formParams,
            {{/hasFormParams}}
        }, initOverrides);

        {{#returnType}}
        {{#isResponseFile}}
        const apiResponse = new runtime.BlobApiResponse(response);
        {{/isResponseFile}}
        {{^isResponseFile}}
        {{#returnTypeIsPrimitive}}
        {{#isMap}}
        const apiResponse = new runtime.JSONApiResponse<any>(response);
        {{/isMap}}
        {{#isArray}}
        const apiResponse = new runtime.JSONApiResponse<any>(response);
        {{/isArray}}
        {{#returnSimpleType}}
        const apiResponse = this.isJsonMime(response.headers.get('content-type')) 
            ? new runtime.JSONApiResponse<{{returnType}}>(response)
            : new runtime.TextApiResponse(response) as any;
        {{/returnSimpleType}}
        {{/returnTypeIsPrimitive}}
        {{^returnTypeIsPrimitive}}
        {{#isArray}}
        const apiResponse = new runtime.JSONApiResponse(response{{^withoutRuntimeChecks}}, (jsonValue) => {{#uniqueItems}}new Set({{/uniqueItems}}jsonValue.map({{returnBaseType}}FromJSON){{/withoutRuntimeChecks}}){{#uniqueItems}}){{/uniqueItems}};
        {{/isArray}}
        {{^isArray}}
        {{#isMap}}
        const apiResponse = new runtime.JSONApiResponse(response{{^withoutRuntimeChecks}}, (jsonValue) => runtime.mapValues(jsonValue, {{returnBaseType}}FromJSON){{/withoutRuntimeChecks}});
        {{/isMap}}
        {{^isMap}}
        const apiResponse = new runtime.JSONApiResponse(response, (jsonValue) => {{returnBaseType}}Schema.parse(jsonValue));
        {{/isMap}}
        {{/isArray}}
        {{/returnTypeIsPrimitive}}
        {{/isResponseFile}}
        {{#isResponseOptional}}
        switch (response.status) {
            {{#responses}}
            {{#is2xx}}
            case {{code}}:
                return {{#dataType}}await apiResponse.value(){{/dataType}}{{^dataType}}null{{/dataType}};
            {{/is2xx}}
            {{/responses}}
            default:
                return await apiResponse.value();
        }
        {{/isResponseOptional}}
        {{^isResponseOptional}}
        return await apiResponse.value();
        {{/isResponseOptional}}
        {{/returnType}}
        {{^returnType}}
        // void return type
        {{/returnType}}
    }
    {{/useSingleRequestParameter}}
    {{#useSingleRequestParameter}}
    async {{nickname}}({{#allParams.0}}requestParameters: {{operationIdCamelCase}}Request{{^hasRequiredParams}} = {}{{/hasRequiredParams}}, {{/allParams.0}}initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{{{returnType}}}{{#returnType}}{{#isResponseOptional}} | null | undefined {{/isResponseOptional}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
        {{#allParams.0}}
        const params = {{operationIdCamelCase}}RequestSchema.parse(requestParameters);
        {{#queryParams.0}}
        const queryParameters = {{operationIdCamelCase}}QuerySchema.parse(params);
        {{/queryParams.0}}
        {{/allParams.0}}

        const headerParameters: runtime.HTTPHeaders = {};
        {{#bodyParam}}
        {{^consumes}}
        headerParameters['Content-Type'] = 'application/json';
        {{/consumes}}
        {{#consumes.0}}
        headerParameters['Content-Type'] = '{{{mediaType}}}';
        {{/consumes.0}}
        {{/bodyParam}}
        {{#headerParams}}
        {{#isArray}}
        if (params.{{paramName}} !== undefined) {
            headerParameters['{{baseName}}'] = {{#uniqueItems}}Array.from({{/uniqueItems}}params.{{paramName}}{{#uniqueItems}}){{/uniqueItems}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
        }
        {{/isArray}}
        {{^isArray}}
        if (params.{{paramName}} !== undefined) {
            headerParameters['{{baseName}}'] = String(params.{{paramName}});
        }
        {{/isArray}}
        {{/headerParams}}

        {{#authMethods}}
        {{#isBasic}}
        {{#isBasicBasic}}
        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        {{/isBasicBasic}}
        {{#isBasicBearer}}
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        {{/isBasicBearer}}
        {{/isBasic}}
        {{#isApiKey}}
        {{#isKeyInHeader}}
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["{{keyParamName}}"] = await this.configuration.apiKey("{{keyParamName}}");
        }
        {{/isKeyInHeader}}
        {{#isKeyInQuery}}
        if (this.configuration && this.configuration.apiKey) {
            queryParameters["{{keyParamName}}"] = await this.configuration.apiKey("{{keyParamName}}");
        }
        {{/isKeyInQuery}}
        {{/isApiKey}}
        {{#isOAuth}}
        if (this.configuration && this.configuration.accessToken) {
            headerParameters["Authorization"] = await this.configuration.accessToken("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
        }
        {{/isOAuth}}
        {{/authMethods}}

        {{#hasFormParams}}
        const consumes: runtime.Consume[] = [
            {{#consumes}}
            { contentType: '{{{mediaType}}}' },
            {{/consumes}}
        ];
        const canConsumeForm = runtime.canConsumeForm(consumes);
        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        {{#formParams}}
        {{#isFile}}
        useForm = canConsumeForm;
        {{/isFile}}
        {{/formParams}}
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        {{#formParams}}
        {{#isArray}}
        if (params.{{paramName}} !== undefined) {
            {{#isCollectionFormatMulti}}
            params.{{paramName}}.forEach((element) => {
                formParams.append('{{baseName}}{{#useSquareBracketsInArrayNames}}[]{{/useSquareBracketsInArrayNames}}', element as any);
            })
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
            formParams.append('{{baseName}}{{#useSquareBracketsInArrayNames}}[]{{/useSquareBracketsInArrayNames}}', {{#uniqueItems}}Array.from({{/uniqueItems}}params.{{paramName}}{{#uniqueItems}}){{/uniqueItems}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]));
            {{/isCollectionFormatMulti}}
        }
        {{/isArray}}
        {{^isArray}}
        if (params.{{paramName}} !== undefined) {
            {{#isDateTimeType}}
            formParams.append('{{baseName}}', (params.{{paramName}} as any).toISOString());
            {{/isDateTimeType}}
            {{^isDateTimeType}}
            {{#isPrimitiveType}}
            formParams.append('{{baseName}}', params.{{paramName}} as any);
            {{/isPrimitiveType}}
            {{^isPrimitiveType}}
            {{#isEnumRef}}
            formParams.append('{{baseName}}', params.{{paramName}} as any);
            {{/isEnumRef}}
            {{^isEnumRef}}
            {{^withoutRuntimeChecks}}
            formParams.append('{{baseName}}', new Blob([JSON.stringify(params.{{paramName}})], { type: "application/json", }));
            {{/withoutRuntimeChecks}}{{#withoutRuntimeChecks}}
            formParams.append('{{baseName}}', new Blob([JSON.stringify(params.{{paramName}})], { type: "application/json", }));
            {{/withoutRuntimeChecks}}
            {{/isEnumRef}}
            {{/isPrimitiveType}}
            {{/isDateTimeType}}
        }
        {{/isArray}}
        {{/formParams}}
        {{/hasFormParams}}

        const response = await this.request({
            path: `{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String(params.{{paramName}}))){{/pathParams}},
            method: '{{httpMethod}}',
            headers: headerParameters,
            {{#queryParams.0}}query: queryParameters,{{/queryParams.0}}
            {{#hasBodyParam}}
            {{#bodyParam}}
            {{#isContainer}}
            {{^withoutRuntimeChecks}}
            body: params.{{paramName}}{{#isArray}}{{/isArray}},
            {{/withoutRuntimeChecks}}
            {{#withoutRuntimeChecks}}
            body: params.{{paramName}},
            {{/withoutRuntimeChecks}}
            {{/isContainer}}
            {{^isContainer}}
            {{^isPrimitiveType}}
             body: params.{{paramName}},            {{/isPrimitiveType}}
            {{#isPrimitiveType}}
            body: params.{{paramName}} as any,
            {{/isPrimitiveType}}
            {{/isContainer}}
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{#hasFormParams}}
            body: formParams,
            {{/hasFormParams}}
        }, initOverrides);

        {{#returnType}}
        {{#isResponseFile}}
        const apiResponse = new runtime.BlobApiResponse(response);
        {{/isResponseFile}}
        {{^isResponseFile}}
        {{#returnTypeIsPrimitive}}
        {{#isMap}}
        const apiResponse = new runtime.JSONApiResponse<any>(response);
        {{/isMap}}
        {{#isArray}}
        const apiResponse = new runtime.JSONApiResponse<any>(response);
        {{/isArray}}
        {{#returnSimpleType}}
        const apiResponse = this.isJsonMime(response.headers.get('content-type')) 
            ? new runtime.JSONApiResponse<{{returnType}}>(response)
            : new runtime.TextApiResponse(response) as any;
        {{/returnSimpleType}}
        {{/returnTypeIsPrimitive}}
        {{^returnTypeIsPrimitive}}
        {{#isArray}}
        const apiResponse = new runtime.JSONApiResponse(response{{^withoutRuntimeChecks}}, (jsonValue) => {{#uniqueItems}}new Set({{/uniqueItems}}jsonValue.map({{returnBaseType}}FromJSON){{/withoutRuntimeChecks}}){{#uniqueItems}}){{/uniqueItems}};
        {{/isArray}}
        {{^isArray}}
        {{#isMap}}
        const apiResponse = new runtime.JSONApiResponse(response{{^withoutRuntimeChecks}}, (jsonValue) => runtime.mapValues(jsonValue, {{returnBaseType}}FromJSON){{/withoutRuntimeChecks}});
        {{/isMap}}
        {{^isMap}}
        const apiResponse = new runtime.JSONApiResponse(response, (jsonValue) => {{returnBaseType}}Schema.parse(jsonValue));
        {{/isMap}}
        {{/isArray}}
        {{/returnTypeIsPrimitive}}
        {{/isResponseFile}}
        {{#isResponseOptional}}
        switch (response.status) {
            {{#responses}}
            {{#is2xx}}
            case {{code}}:
                return {{#dataType}}await apiResponse.value(){{/dataType}}{{^dataType}}null{{/dataType}};
            {{/is2xx}}
            {{/responses}}
            default:
                return await apiResponse.value();
        }
        {{/isResponseOptional}}
        {{^isResponseOptional}}
        return await apiResponse.value();
        {{/isResponseOptional}}
        {{/returnType}}
        {{^returnType}}
        // void return type
        {{/returnType}}
    }
    {{/useSingleRequestParameter}}

    {{/operation}}
}
{{/operations}}
{{#hasEnums}}

{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
{{#stringEnums}}
/**
  * @export
  * @enum {string}
  */
export enum {{operationIdCamelCase}}{{enumName}} {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}} = {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
}
{{/stringEnums}}
{{^stringEnums}}
/**
 * @export
 */
export const {{operationIdCamelCase}}{{enumName}} = {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}}: {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
} as const;
export type {{operationIdCamelCase}}{{enumName}} = typeof {{operationIdCamelCase}}{{enumName}}[keyof typeof {{operationIdCamelCase}}{{enumName}}];
{{/stringEnums}}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
{{/hasEnums}}
